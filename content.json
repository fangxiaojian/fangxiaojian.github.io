{"meta":{"title":"小贱の博客","subtitle":"Our pride chiefly rests on ignorance","description":"懒人无法享受休息之乐","author":"小贱","url":"https://www.xiaojianblog.top","root":"/"},"pages":[{"title":"分类","date":"2019-07-08T03:42:40.000Z","updated":"2019-07-08T10:34:55.000Z","comments":false,"path":"categories/index.html","permalink":"https://www.xiaojianblog.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-08T08:31:14.000Z","updated":"2019-07-08T10:35:58.000Z","comments":false,"path":"tags/index.html","permalink":"https://www.xiaojianblog.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java高级-1JVM","slug":"Java高级-1JVM","date":"2019-08-02T00:31:52.000Z","updated":"2019-08-25T11:49:17.000Z","comments":true,"path":"2019/08/02/Java高级-1JVM/","link":"","permalink":"https://www.xiaojianblog.top/2019/08/02/Java%E9%AB%98%E7%BA%A7-1JVM/","excerpt":"运行时数据区域","text":"运行时数据区域 程序计数器记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。 程序计数器为什么是私有的?程序计数器主要有下面两个作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。 所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。 Java 虚拟机栈​ 每个 Java 方法在执行的同时会创建一个 栈帧 用于存储 局部变量表、操作数栈、常量池引用 等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 ​ 局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。 ​ 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M： 1java -Xss2M HackTheJava 该区域可能抛出以下异常： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。 本地方法栈​ 本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 ​ 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。 虚拟机栈和本地方法栈为什么是私有的? 虚拟机栈： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。 堆​ 所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。 ​ 现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块： 新生代（Young Generation） 老年代（Old Generation） ​ 再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。 ​ 上图所示的 eden 区、s0 区、s1 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1 (Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。 ​ 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 ​ 可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。 1java -Xms1M -Xmx2M HackTheJava 方法区​ 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 ​ 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。 ​ 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。 ​ HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。 ​ 方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。 运行时常量池​ 运行时常量池是方法区的一部分。 ​ Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。 ​ 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。 直接内存​ 在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。 垃圾收集​ 垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。 判断一个对象是否可被回收① 引用计数算法​ 为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 ​ 在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。 1234567891011121314public class Test &#123; public Object instance = null; public static void main(String[] args) &#123; Test a = new Test(); Test b = new Test(); a.instance = b; b.instance = a; a = null; b = null; doSomething(); &#125;&#125; ​ 在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。 ② 可达性分析算法以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。 Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容： 虚拟机栈中局部变量表中引用的对象 本地方法栈中 JNI 中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 ③ 方法区的回收因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。 为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。 类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载： 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 ④ finalize()​ 类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。 ​ 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。 引用类型​ 无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。 Java 提供了四种强度不同的引用类型。 ① 强引用被强引用关联的对象不会被回收。 使用 new 一个新对象的方式来创建强引用。 1Object obj = new Object(); ② 软引用被软引用关联的对象只有在内存不够的情况下才会被回收。 使用 SoftReference 类来创建软引用。 123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 ③ 弱引用被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。 使用 WeakReference 类来创建弱引用。 123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; ④ 虚引用又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。 为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。 使用 PhantomReference 来创建虚引用。 123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);obj = null; 垃圾收集算法① 标记 - 清除 ​ 在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。 ​ 在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。 ​ 在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。 不足： 标记和清除过程效率都不高； 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 ② 标记 - 整理 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 优点: 不会产生内存碎片 不足: 需要移动大量对象，处理效率比较低。 ③ 复制 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。 HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。 ④ 分代收集现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清除 或者 标记 - 整理 算法 垃圾收集器 以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程； 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。 ① Serial 收集器 Serial 翻译为串行，也就是说它以串行的方式执行。 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。 它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。 ② ParNew 收集器 它是 Serial 收集器的多线程版本。 它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。 ③ Parallel Scavenge 收集器与 ParNew 一样是多线程收集器。 其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。 可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。 ④ Serial Old 收集器 是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 ⑤ Parallel Old 收集器 是 Parallel Scavenge 收集器的老年代版本。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 ⑥ CMS 收集器 CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 具有以下缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。 ⑦ G1 收集器G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。 G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 具备如下特点： 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 内存分配与回收策略Minor GC 和 Full GC Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。 内存分配策略① 对象优先在 Eden 分配大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。 ② 大对象直接进入老年代大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。 ③ 长期存活的对象进入老年代为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。 -XX:MaxTenuringThreshold 用来定义年龄的阈值。 ④ 4. 动态对象年龄判定虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 ⑤ 空间分配担保在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。 如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 Full GC 的触发条件对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： ① 调用 System.gc()只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 ② 老年代空间不足老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。 ③ 空间分配担保失败使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。 ④ JDK 1.7 及以前的永久代空间不足在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。 当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。 为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。 ⑤ Concurrent Mode Failure执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 类加载机制类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。 类的生命周期 包括以下 7 个阶段： 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading） 类加载过程包含了加载、验证、准备、解析和初始化这 5 个阶段。 ① 加载加载是类加载的一个阶段，注意不要混淆。 加载过程完成以下三件事： 通过类的完全限定名称获取定义该类的二进制字节流。 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。 其中二进制字节流可以从以下方式中获取： 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。 从网络中获取，最典型的应用是 Applet。 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。 ② 验证确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 ③ 准备类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。 实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。 初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。 1public static int value = 123; 如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。 1public static final int value = 123; ④ 解析将常量池的符号引用替换为直接引用的过程。 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 ⑤ 初始化初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 () 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 () 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码： 1234567public class Test &#123; static &#123; i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” &#125; static int i = 1;&#125; 由于父类的 () 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码： 1234567891011121314static class Parent &#123; public static int A = 1; static &#123; A = 2; &#125;&#125;static class Sub extends Parent &#123; public static int B = A;&#125;public static void main(String[] args) &#123; System.out.println(Sub.B); // 2&#125; 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 () 方法。但接口与类不同的是，执行接口的 () 方法不需要先执行父接口的 () 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 () 方法。 虚拟机会保证一个类的 () 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 () 方法，其它线程都会阻塞等待，直到活动线程执行 () 方法完毕。如果在一个类的 () 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。 类初始化时机主动引用虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）： 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类； 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化； 被动引用以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括： 通过子类引用父类的静态字段，不会导致子类初始化。 1System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 1SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 1System.out.println(ConstClass.HELLOWORLD); 类与类加载器两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。 这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。 类加载器分类从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分； 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度看，类加载器可以划分得更细致一些： 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 \\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 /lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 双亲委派模型应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。 下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。 工作过程一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。 好处使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。 例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。 实现以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。 1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class ClassLoader &#123; // The parent class loader for delegation private final ClassLoader parent; public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; return loadClass(name, false); &#125; protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. c = findClass(name); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name); &#125;&#125; 自定义类加载器实现以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。 java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。 12345678910111213141516171819202122232425262728293031323334353637383940public class FileSystemClassLoader extends ClassLoader &#123; private String rootDir; public FileSystemClassLoader(String rootDir) &#123; this.rootDir = rootDir; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = getClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] getClassData(String className) &#123; String path = classNameToPath(className); try &#123; InputStream ins = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead; while ((bytesNumRead = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, bytesNumRead); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; private String classNameToPath(String className) &#123; return rootDir + File.separatorChar + className.replace(&#x27;.&#x27;, File.separatorChar) + &quot;.class&quot;; &#125;&#125;","categories":[{"name":"java高级","slug":"java高级","permalink":"https://www.xiaojianblog.top/categories/java%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.xiaojianblog.top/tags/java/"},{"name":"JVM","slug":"JVM","permalink":"https://www.xiaojianblog.top/tags/JVM/"}]},{"title":"Java基础-12Atomic原子类","slug":"Java基础-12Atomic原子类","date":"2019-08-01T14:31:52.000Z","updated":"2019-08-25T11:49:17.000Z","comments":true,"path":"2019/08/01/Java基础-12Atomic原子类/","link":"","permalink":"https://www.xiaojianblog.top/2019/08/01/Java%E5%9F%BA%E7%A1%80-12Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB/","excerpt":"介绍​ Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。","text":"介绍​ Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。 ​ 所以，所谓原子类说简单点就是具有原子/原子操作特征的类。 ​ 并发包 java.util.concurrent 的原子类都存放在 java.util.concurrent.atomic下,如下图所示。 根据操作的数据类型，可以将JUC包中的原子类分为4类 基本类型 使用原子的方式更新基本类型 AtomicInteger：整型原子类 AtomicLong：长整型原子类 AtomicBoolean ：布尔型原子类 数组类型 使用原子的方式更新数组里的某个元素 AtomicIntegerArray：整型数组原子类 AtomicLongArray：长整型数组原子类 AtomicReferenceArray ：引用类型数组原子类 引用类型 AtomicReference：引用类型原子类 AtomicStampedReference：原子更新引用类型里的字段原子类 AtomicMarkableReference ：原子更新带有标记位的引用类型 对象的属性修改类型 AtomicIntegerFieldUpdater:原子更新整型字段的更新器 AtomicLongFieldUpdater：原子更新长整型字段的更新器 AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 CAS 的 ABA 问题 描述: 第一个线程取到了变量 x 的值 A，然后巴拉巴拉干别的事，总之就是只拿到了变量 x 的值 A。这段时间内第二个线程也取到了变量 x 的值 A，然后把变量 x 的值改为 B，然后巴拉巴拉干别的事，最后又把变量 x 的值变为 A （相当于还原了）。在这之后第一个线程终于进行了变量 x 的操作，但是此时变量 x 的值还是 A，所以 compareAndSet 操作是成功。 例子描述(可能不太合适，但好理解): 年初，现金为零，然后通过正常劳动赚了三百万，之后正常消费了（比如买房子）三百万。年末，虽然现金零收入（可能变成其他形式了），但是赚了钱是事实，还是得交税的！ 代码例子（以 AtomicInteger 为例） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.concurrent.atomic.AtomicInteger;public class AtomicIntegerDefectDemo &#123; public static void main(String[] args) &#123; defectOfABA(); &#125; static void defectOfABA() &#123; final AtomicInteger atomicInteger = new AtomicInteger(1); Thread coreThread = new Thread( () -&gt; &#123; final int currentValue = atomicInteger.get(); System.out.println(Thread.currentThread().getName() + &quot; ------ currentValue=&quot; + currentValue); // 这段目的：模拟处理其他业务花费的时间 try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; boolean casResult = atomicInteger.compareAndSet(1, 2); System.out.println(Thread.currentThread().getName() + &quot; ------ currentValue=&quot; + currentValue + &quot;, finalValue=&quot; + atomicInteger.get() + &quot;, compareAndSet Result=&quot; + casResult); &#125; ); coreThread.start(); // 这段目的：为了让 coreThread 线程先跑起来 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Thread amateurThread = new Thread( () -&gt; &#123; int currentValue = atomicInteger.get(); boolean casResult = atomicInteger.compareAndSet(1, 2); System.out.println(Thread.currentThread().getName() + &quot; ------ currentValue=&quot; + currentValue + &quot;, finalValue=&quot; + atomicInteger.get() + &quot;, compareAndSet Result=&quot; + casResult); currentValue = atomicInteger.get(); casResult = atomicInteger.compareAndSet(2, 1); System.out.println(Thread.currentThread().getName() + &quot; ------ currentValue=&quot; + currentValue + &quot;, finalValue=&quot; + atomicInteger.get() + &quot;, compareAndSet Result=&quot; + casResult); &#125; ); amateurThread.start(); &#125;&#125; 输出内容如下： 1234Thread-0 ------ currentValue=1Thread-1 ------ currentValue=1, finalValue=2, compareAndSet Result=trueThread-1 ------ currentValue=2, finalValue=1, compareAndSet Result=trueThread-0 ------ currentValue=1, finalValue=2, compareAndSet Result=true 下面我们来详细介绍一下这些原子类。 基本类型原子类介绍使用原子的方式更新基本类型 AtomicInteger：整型原子类 AtomicLong：长整型原子类 AtomicBoolean ：布尔型原子类 上面三个类提供的方法几乎相同，所以我们这里以 AtomicInteger 为例子来介绍。 AtomicInteger 类常用方法 1234567public final int get() //获取当前的值public final int getAndSet(int newValue)//获取当前的值，并设置新的值public final int getAndIncrement()//获取当前的值，并自增public final int getAndDecrement() //获取当前的值，并自减public final int getAndAdd(int delta) //获取当前的值，并加上预期的值boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 AtomicInteger 常见方法使用1234567891011121314151617import java.util.concurrent.atomic.AtomicInteger;public class AtomicIntegerTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int temvalue = 0; AtomicInteger i = new AtomicInteger(0); temvalue = i.getAndSet(3); System.out.println(&quot;temvalue:&quot; + temvalue + &quot;; i:&quot; + i);//temvalue:0; i:3 temvalue = i.getAndIncrement(); System.out.println(&quot;temvalue:&quot; + temvalue + &quot;; i:&quot; + i);//temvalue:3; i:4 temvalue = i.getAndAdd(5); System.out.println(&quot;temvalue:&quot; + temvalue + &quot;; i:&quot; + i);//temvalue:4; i:9 &#125;&#125; 基本数据类型原子类的优势通过一个简单例子带大家看一下基本数据类型原子类的优势 ① 多线程环境不使用原子类保证线程安全（基本数据类型） 1234567891011class Test &#123; private volatile int count = 0; //若要线程安全执行执行count++，需要加锁 public synchronized void increment() &#123; count++; &#125; public int getCount() &#123; return count; &#125;&#125; ② 多线程环境使用原子类保证线程安全（基本数据类型） 1234567891011class Test2 &#123; private AtomicInteger count = new AtomicInteger(); public void increment() &#123; count.incrementAndGet(); &#125; //使用AtomicInteger之后，不需要加锁，也可以实现线程安全。 public int getCount() &#123; return count.get(); &#125;&#125; AtomicInteger 线程安全原理简单分析AtomicInteger 类的部分源码： 123456789101112// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）private static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125;private volatile int value; ​ AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。 ​ CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到 “原来的值” 的内存地址。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。 数组类型原子类介绍使用原子的方式更新数组里的某个元素 AtomicIntegerArray：整形数组原子类 AtomicLongArray：长整形数组原子类 AtomicReferenceArray ：引用类型数组原子类 上面三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerArray 为例子来介绍。 AtomicIntegerArray 类常用方法 1234567public final int get(int i) //获取 index=i 位置元素的值public final int getAndSet(int i, int newValue)//返回 index=i 位置的当前的值，并将其设置为新值：newValuepublic final int getAndIncrement(int i)//获取 index=i 位置元素的值，并让该位置的元素自增public final int getAndDecrement(int i) //获取 index=i 位置元素的值，并让该位置的元素自减public final int getAndAdd(int delta) //获取 index=i 位置元素的值，并加上预期的值boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）public final void lazySet(int i, int newValue)//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 AtomicIntegerArray 常见方法使用123456789101112131415161718192021import java.util.concurrent.atomic.AtomicIntegerArray;public class AtomicIntegerArrayTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int temvalue = 0; int[] nums = &#123; 1, 2, 3, 4, 5, 6 &#125;; AtomicIntegerArray i = new AtomicIntegerArray(nums); for (int j = 0; j &lt; nums.length; j++) &#123; System.out.println(i.get(j)); &#125; temvalue = i.getAndSet(0, 2); System.out.println(&quot;temvalue:&quot; + temvalue + &quot;; i:&quot; + i); temvalue = i.getAndIncrement(0); System.out.println(&quot;temvalue:&quot; + temvalue + &quot;; i:&quot; + i); temvalue = i.getAndAdd(0, 5); System.out.println(&quot;temvalue:&quot; + temvalue + &quot;; i:&quot; + i); &#125;&#125; 引用类型原子类介绍基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。 AtomicReference：引用类型原子类 AtomicStampedReference：原子更新引用类型里的字段原子类 AtomicMarkableReference ：原子更新带有标记位的引用类型 上面三个类提供的方法几乎相同，所以我们这里以 AtomicReference 为例子来介绍。 AtomicReference 类使用示例12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.atomic.AtomicReference;public class AtomicReferenceTest &#123; public static void main(String[] args) &#123; AtomicReference&lt;Person&gt; ar = new AtomicReference&lt;Person&gt;(); Person person = new Person(&quot;SnailClimb&quot;, 22); ar.set(person); Person updatePerson = new Person(&quot;Daisy&quot;, 20); ar.compareAndSet(person, updatePerson); System.out.println(ar.get().getName()); System.out.println(ar.get().getAge()); &#125;&#125;class Person &#123; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; ​ 上述代码首先创建了一个 Person 对象，然后把 Person 对象设置进 AtomicReference 对象中，然后调用 compareAndSet 方法，该方法就是通过通过 CAS 操作设置 ar。如果 ar 的值为 person 的话，则将其设置为 updatePerson。实现原理与 AtomicInteger 类中的 compareAndSet 方法相同。运行上面的代码后的输出结果如下： 12Daisy20 AtomicStampedReference 类使用示例12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.atomic.AtomicStampedReference;public class AtomicStampedReferenceDemo &#123; public static void main(String[] args) &#123; // 实例化、取当前值和 stamp 值 final Integer initialRef = 0, initialStamp = 0; final AtomicStampedReference&lt;Integer&gt; asr = new AtomicStampedReference&lt;&gt;(initialRef, initialStamp); System.out.println(&quot;currentValue=&quot; + asr.getReference() + &quot;, currentStamp=&quot; + asr.getStamp()); // compare and set final Integer newReference = 666, newStamp = 999; final boolean casResult = asr.compareAndSet(initialRef, newReference, initialStamp, newStamp); System.out.println(&quot;currentValue=&quot; + asr.getReference() + &quot;, currentStamp=&quot; + asr.getStamp() + &quot;, casResult=&quot; + casResult); // 获取当前的值和当前的 stamp 值 int[] arr = new int[1]; final Integer currentValue = asr.get(arr); final int currentStamp = arr[0]; System.out.println(&quot;currentValue=&quot; + currentValue + &quot;, currentStamp=&quot; + currentStamp); // 单独设置 stamp 值 final boolean attemptStampResult = asr.attemptStamp(newReference, 88); System.out.println(&quot;currentValue=&quot; + asr.getReference() + &quot;, currentStamp=&quot; + asr.getStamp() + &quot;, attemptStampResult=&quot; + attemptStampResult); // 重新设置当前值和 stamp 值 asr.set(initialRef, initialStamp); System.out.println(&quot;currentValue=&quot; + asr.getReference() + &quot;, currentStamp=&quot; + asr.getStamp()); // [不推荐使用，除非搞清楚注释的意思了] weak compare and set // 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191] // 但是注释上写着 &quot;May fail spuriously and does not provide ordering guarantees, // so is only rarely an appropriate alternative to compareAndSet.&quot; // todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发 final boolean wCasResult = asr.weakCompareAndSet(initialRef, newReference, initialStamp, newStamp); System.out.println(&quot;currentValue=&quot; + asr.getReference() + &quot;, currentStamp=&quot; + asr.getStamp() + &quot;, wCasResult=&quot; + wCasResult); &#125;&#125; 输出结果如下： 123456currentValue=0, currentStamp=0currentValue=666, currentStamp=999, casResult=truecurrentValue=666, currentStamp=999currentValue=666, currentStamp=88, attemptStampResult=truecurrentValue=0, currentStamp=0currentValue=666, currentStamp=999, wCasResult=true AtomicMarkableReference 类使用示例12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.atomic.AtomicMarkableReference;public class AtomicMarkableReferenceDemo &#123; public static void main(String[] args) &#123; // 实例化、取当前值和 mark 值 final Boolean initialRef = null, initialMark = false; final AtomicMarkableReference&lt;Boolean&gt; amr = new AtomicMarkableReference&lt;&gt;(initialRef, initialMark); System.out.println(&quot;currentValue=&quot; + amr.getReference() + &quot;, currentMark=&quot; + amr.isMarked()); // compare and set final Boolean newReference1 = true, newMark1 = true; final boolean casResult = amr.compareAndSet(initialRef, newReference1, initialMark, newMark1); System.out.println(&quot;currentValue=&quot; + amr.getReference() + &quot;, currentMark=&quot; + amr.isMarked() + &quot;, casResult=&quot; + casResult); // 获取当前的值和当前的 mark 值 boolean[] arr = new boolean[1]; final Boolean currentValue = amr.get(arr); final boolean currentMark = arr[0]; System.out.println(&quot;currentValue=&quot; + currentValue + &quot;, currentMark=&quot; + currentMark); // 单独设置 mark 值 final boolean attemptMarkResult = amr.attemptMark(newReference1, false); System.out.println(&quot;currentValue=&quot; + amr.getReference() + &quot;, currentMark=&quot; + amr.isMarked() + &quot;, attemptMarkResult=&quot; + attemptMarkResult); // 重新设置当前值和 mark 值 amr.set(initialRef, initialMark); System.out.println(&quot;currentValue=&quot; + amr.getReference() + &quot;, currentMark=&quot; + amr.isMarked()); // [不推荐使用，除非搞清楚注释的意思了] weak compare and set // 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191] // 但是注释上写着 &quot;May fail spuriously and does not provide ordering guarantees, // so is only rarely an appropriate alternative to compareAndSet.&quot; // todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发 final boolean wCasResult = amr.weakCompareAndSet(initialRef, newReference1, initialMark, newMark1); System.out.println(&quot;currentValue=&quot; + amr.getReference() + &quot;, currentMark=&quot; + amr.isMarked() + &quot;, wCasResult=&quot; + wCasResult); &#125;&#125; 输出结果如下： 123456currentValue=null, currentMark=falsecurrentValue=true, currentMark=true, casResult=truecurrentValue=true, currentMark=truecurrentValue=true, currentMark=false, attemptMarkResult=truecurrentValue=null, currentMark=falsecurrentValue=true, currentMark=true, wCasResult=true 对象的属性修改类型原子类介绍如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。 AtomicIntegerFieldUpdater:原子更新整形字段的更新器 AtomicLongFieldUpdater：原子更新长整形字段的更新器 AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater() 创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。 上面三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerFieldUpdater为例子来介绍。 AtomicIntegerFieldUpdater 类使用示例1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;public class AtomicIntegerFieldUpdaterTest &#123; public static void main(String[] args) &#123; AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, &quot;age&quot;); User user = new User(&quot;Java&quot;, 22); System.out.println(a.getAndIncrement(user));// 22 System.out.println(a.get(user));// 23 &#125;&#125;class User &#123; private String name; public volatile int age; public User(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 输出结果： 122223","categories":[{"name":"java基础","slug":"java基础","permalink":"https://www.xiaojianblog.top/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.xiaojianblog.top/tags/java/"}]},{"title":"Java基础-11并发容器","slug":"Java基础-11并发容器","date":"2019-08-01T12:31:52.000Z","updated":"2019-08-25T11:49:17.000Z","comments":true,"path":"2019/08/01/Java基础-11并发容器/","link":"","permalink":"https://www.xiaojianblog.top/2019/08/01/Java%E5%9F%BA%E7%A1%80-11%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/","excerpt":"JDK 提供的并发容器总结JDK提供的这些容器大部分在 java.util.concurrent 包中。","text":"JDK 提供的并发容器总结JDK提供的这些容器大部分在 java.util.concurrent 包中。 ConcurrentHashMap : 线程安全的 HashMap CopyOnWriteArrayList : 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector. ConcurrentLinkedQueue : 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。 BlockingQueue : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。 ConcurrentSkipListMap : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。 ConcurrentHashMap​ 我们知道 HashMap 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 Collections.synchronizedMap() 方法来包装我们的 HashMap。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。 ​ 所以就有了 HashMap 的线程安全版本—— ConcurrentHashMap 的诞生。在 ConcurrentHashMap 中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。 CopyOnWriteArrayList简介12public class CopyOnWriteArrayList&lt;E&gt; extends Objectimplements List&lt;E&gt;, RandomAccess, Cloneable, Serializable ​ 在很多应用场景中，读操作可能会远远大于写操作。由于读操作根本不会修改原有的数据，因此对于每次读取都进行加锁其实是一种资源浪费。我们应该允许多个线程同时访问 List 的内部数据，毕竟读取操作是安全的。 ​ 这和我们之前在锁章节讲过 ReentrantReadWriteLock 读写锁的思想非常类似，也就是读读共享、写写互斥、读写互斥、写读互斥。JDK 中提供了 CopyOnWriteArrayList 类比相比于在读写锁的思想又更进一步。为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。这样一来，读操作的性能就会大幅度提升。那它是怎么做的呢？ CopyOnWriteArrayList 是如何做到的​ CopyOnWriteArrayList 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。 ​ 从 CopyOnWriteArrayList 的名字就能看出 CopyOnWriteArrayList 是满足 CopyOnWrite 的 ArrayList ，所谓 CopyOnWrite 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。 CopyOnWriteArrayList 读取和写入源码简单分析CopyOnWriteArrayList 读取操作的实现​ 读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。 123456789101112/** The array, accessed only via getArray/setArray. */ private transient volatile Object[] array; public E get(int index) &#123; return get(getArray(), index); &#125; @SuppressWarnings(&quot;unchecked&quot;)private E get(Object[] a, int index) &#123; return (E) a[index]; &#125; final Object[] getArray() &#123; return array; &#125; CopyOnWriteArrayList 写入操作的实现​ CopyOnWriteArrayList 写入操作 add() 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。 1234567891011121314151617181920/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock();//加锁 try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1);//拷贝新数组 newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock();//释放锁 &#125;&#125; ConcurrentLinkedQueue​ Java 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue ，非阻塞队列的典型例子是 ConcurrentLinkedQueue ，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。 ​ 从名字可以看出，ConcurrentLinkedQueue 这个队列使用链表作为其数据结构。 ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。 ​ ConcurrentLinkedQueue 内部代码我们就不分析了，大家知道 ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全就好了。 ​ ConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。 BlockingQueue简介​ 上面我们己经提到了 ConcurrentLinkedQueue 作为高性能的非阻塞队列。下面我们要讲到的是阻塞队列——BlockingQueue。阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。 ​ BlockingQueue 是一个接口，继承自 Queue，所以其实现类也可以作为 Queue 的实现来使用，而 Queue 又继承自 Collection 接口。下面是 BlockingQueue 的相关实现类： 下面主要介绍一下: ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue，这三个 BlockingQueue 的实现类。 ArrayBlockingQueue​ ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。 ​ ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，当 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue 。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 ArrayBlockingQueue，可采用如下代码： 1private static ArrayBlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;Integer&gt;(10,true); LinkedBlockingQueue​ LinkedBlockingQueue 底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE。 相关构造方法: 12345678910111213141516171819202122/** *某种意义上的无界队列 * Creates a &#123;@code LinkedBlockingQueue&#125; with a capacity of * &#123;@link Integer#MAX_VALUE&#125;. */public LinkedBlockingQueue() &#123; this(Integer.MAX_VALUE);&#125;/** *有界队列 * Creates a &#123;@code LinkedBlockingQueue&#125; with the given (fixed) capacity. * * @param capacity the capacity of this queue * @throws IllegalArgumentException if &#123;@code capacity&#125; is not greater * than zero */public LinkedBlockingQueue(int capacity) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; last = head = new Node&lt;E&gt;(null);&#125; PriorityBlockingQueue​ PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。 ​ PriorityBlockingQueue 并发控制采用的是 ReentrantLock，队列为无界队列（ ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。 ​ 简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。 ConcurrentSkipListMap为了引出ConcurrentSkipListMap，先带着大家简单理解一下跳表。 ​ 对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 O(logn) 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。 ​ 跳表的本质是同时维护了多个链表，并且链表是分层的， ​ 最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。 ​ 跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。如上图所示，在跳表中查找元素18。 ​ 查找18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。 ​ 从上面很容易看出，跳表是一种利用空间换时间的算法。 ​ 使用跳表实现Map 和使用哈希算法实现Map的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是 ConcurrentSkipListMap。","categories":[{"name":"java基础","slug":"java基础","permalink":"https://www.xiaojianblog.top/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.xiaojianblog.top/tags/java/"}]},{"title":"Java基础-10锁","slug":"Java基础-10锁","date":"2019-08-01T02:31:52.000Z","updated":"2019-08-14T08:35:15.000Z","comments":true,"path":"2019/08/01/Java基础-10锁/","link":"","permalink":"https://www.xiaojianblog.top/2019/08/01/Java%E5%9F%BA%E7%A1%80-10%E9%94%81/","excerpt":"线程安全多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。","text":"线程安全多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。 线程安全有以下几种实现方式： 不可变​ 不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。 不可变的类型： final 关键字修饰的基本数据类型 String 枚举类型 Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。 对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。 1234567public class ImmutableExample &#123; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map); unmodifiableMap.put(&quot;a&quot;, 1); &#125;&#125; 123Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1457) at ImmutableExample.main(ImmutableExample.java:9) Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。 123public V put(K key, V value) &#123; throw new UnsupportedOperationException();&#125; 互斥同步​ 互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。 ​ 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。 加锁：synchronized 和 ReentrantLock 非阻塞同步​ 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。 CAS​ 乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。 AtomicIntegerJ.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。 以下代码使用了 AtomicInteger 执行了自增的操作。 12345private AtomicInteger cnt = new AtomicInteger();public void add() &#123; cnt.incrementAndGet();&#125; 以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。 123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125; ​ 以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5 ，那么就更新内存地址为 var1+var2 的变量为 var5+var4。 可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); // 旧的预期值 &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; ABA​ 如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。 ​ J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。 无同步方案​ 要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。 栈封闭​ 多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。 123456789public class StackClosedExample &#123; public void add100() &#123; int cnt = 0; for (int i = 0; i &lt; 100; i++) &#123; cnt++; &#125; System.out.println(cnt); &#125;&#125; 1234567public static void main(String[] args) &#123; StackClosedExample example = new StackClosedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; example.add100()); executorService.execute(() -&gt; example.add100()); executorService.shutdown();&#125; 12100100 线程本地存储（Thread Local Storage）​ 如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。 ​ 符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的 “一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。 ​ 可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。 ​ 对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。 123456789101112131415161718192021public class ThreadLocalExample &#123; public static void main(String[] args) &#123; ThreadLocal threadLocal = new ThreadLocal(); Thread thread1 = new Thread(() -&gt; &#123; threadLocal.set(1); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(threadLocal.get()); threadLocal.remove(); &#125;); Thread thread2 = new Thread(() -&gt; &#123; threadLocal.set(2); threadLocal.remove(); &#125;); thread1.start(); thread2.start(); &#125;&#125; 11 为了理解 ThreadLocal，先看以下代码： 12345678910111213141516public class ThreadLocalExample1 &#123; public static void main(String[] args) &#123; ThreadLocal threadLocal1 = new ThreadLocal(); ThreadLocal threadLocal2 = new ThreadLocal(); Thread thread1 = new Thread(() -&gt; &#123; threadLocal1.set(1); threadLocal2.set(1); &#125;); Thread thread2 = new Thread(() -&gt; &#123; threadLocal1.set(2); threadLocal2.set(2); &#125;); thread1.start(); thread2.start(); &#125;&#125; 它所对应的底层结构图为： 每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; get() 方法类似。 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。 在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。 可重入代码（Reentrant Code）​ 这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。 ​ 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。 volatilevolatile 具有两大特性： 禁止重排序 内存可见性 常用于单例模式中修饰单例变量，防止指令重排序； 修饰成员变量，使得多线程并发操作下的共享变量在各个线程间互相可见。 内存可见性的原理​ 当前的 Java 内存模型下，线程可以把变量保存本地内存比如机器的寄存器中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 ​ 要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。 ​ 说白了， volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。 synchronized最主要的三种使用方式 修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！ 双重校验锁实现对象单例（线程安全）1234567891011121314151617181920public class Singleton &#123; private volatile static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getSingleton() &#123; //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (singleton == null) &#123; //类对象加锁 synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 另外，需要注意 singleton 采用 volatile 关键字修饰也是很有必要的 singleton = new Singleton(); 这段代码其实是分为三步执行： 为 singleton 分配内存空间 初始化 singleton 将 singleton 指向分配的内存地址 ​ 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getSingleton() 后发现 singleton 不为空，因此返回 singleton ，但此时 singleton 还未被初始化。 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 synchronized 关键字底层原理synchronized 关键字底层原理属于 JVM 层面。 ① synchronized 同步代码块的情况1234567public class SynchronizedDemo &#123; public void method() &#123; synchronized (this) &#123; System.out.println(&quot;synchronized 代码块&quot;); &#125; &#125;&#125; 通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息： 切换到类的对应目录执行 javac SynchronizedDemo.java 命令生成编译后的 .class 文件 执行javap -c -s -v -l SynchronizedDemo.class 从上面我们可以看出： ​ synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 ​ 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor (monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。 当计数器为 0 则可以成功获取，获取后将锁计数器设为 1 也就是加 1。相应的在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。 ② synchronized 修饰方法的的情况12345public class SynchronizedDemo2 &#123; public synchronized void method() &#123; System.out.println(&quot;synchronized 方法&quot;); &#125;&#125; ​ synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 ​ 在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。 ​ 在 JDK1.6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 JDK1.6 之后的底层优化​ JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。 ​ 锁主要存在四中状态，依次是： 无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态 ​ 他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。 ① 偏向锁​ 引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。 ​ 偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！ ​ 但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，**偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁**。 ② 轻量级锁​ 倘若 偏向锁 失败，虚拟机并不会立即升级为 重量级锁，它还会尝试使用一种称为 轻量级锁 的优化手段( JDK1.6 之后加入的)。**轻量级锁 不是为了代替 重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的 重量级锁 使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁 的加锁和解锁都用到了CAS操作。** ​ 轻量级锁 能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生 CAS 操作，因此在有锁竞争的情况下，轻量级锁 比传统的 重量级锁 更慢！如果锁竞争激烈，那么 轻量级 将很快膨胀为 重量级锁！ ③ 自旋锁和自适应自旋​ 轻量级锁 失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为 自旋锁 的优化手段。 ​ 互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。 ​ 一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。 百度百科对自旋锁的解释： ​ 何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。 ​ 自旋锁在 JDK1.6 之前其实就已经引入了，不过是默认关闭的，需要通过 --XX:+UseSpinning 参数来开启。JDK1.6 及 1.6 之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。自旋次数的默认值是 10 次，用户可以修改 --XX:PreBlockSpin 来更改。 ​ 另外,在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了。 ④ 锁消除​ 锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。 ​ 锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。 ​ 对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁： 123public static String concatString(String s1, String s2, String s3) &#123; return s1 + s2 + s3;&#125; ​ String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作： 1234567public static String concatString(String s1, String s2, String s3) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); sb.append(s3); return sb.toString();&#125; ​ 每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。 ⑤ 锁粗化​ 原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，—直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。 ​ 大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。 ⑥ 可重入锁可重入的条件： 不在函数内使用静态或全局数据。 不返回静态或全局数据，所有数据都由函数的调用者提供。 使用本地数据（工作内存），或者通过制作全局数据的本地拷贝来保护全局数据。 不调用不可重入函数。 ​ 每个锁关联一个线程持有者和一个计数器。当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM 会记下持有锁的线程，并将计数器计为 1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个 synchronized方法/块 时，计数器会递减，如果计数器为 0 则释放该锁。 ⑦ 重量级锁​ 内置锁在 Java 中被抽象为监视器锁（monitor）。在 JDK 1.6 之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。 synchronized 和 volatile 的区别 volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定比 synchronized 关键字要好。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。synchronized 关键字在 JDK1.6 之后进行了主要包括为了减少 获得锁和释放锁 带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。 多线程访问 volatile 关键字不会发生阻塞，而 synchronized 关键字可能会发生阻塞 volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。 volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。 synchronized 与 Lock 的区别相同点：两者都是用来实现对某个资源的同步。 两者区别如下： (1) 用法不一样。synchronized 可以用于修饰方法，也可以用在代码块中。Lock 需要指定起始和终点位置，一般放在 try-finally 结构中，try 开始执行 lock 方法，finally 中执行 unlock 方法。synchronized 是托管给 JVM 执行的，Lock 是通过代码执行的。 (2) 性能不一样。在资源竞争不激烈情况下，synchronized 的性能比 Lock 好，而在资源竞争激烈时，synchronized 的性能下降很快，而 Lock 基本保持不变。 Lock 功能更强大，可以实现等待可中断，可实现公平锁，可指定唤醒。由于 JDK 1.6 之后出现的锁粗化，锁消除，偏向锁等优化，性能已经不是必要因素 (3) 锁机制不一样。synchronized 异常后自动释放锁，而 Lock 需要手动释放锁 ReentrantLock简介​ ReentrantLock 可重入锁，顾名思义，就是支持重入的锁，它表示能够支持一个线程对资源的重复加锁；我们之前学习过 Synchronized 锁，它也是支持重入的一种锁，Synchronized 支持隐式的重入锁，比如递归方法，在方法运行时，执行线程在获取到了锁之后仍能连续多次地获取锁；ReentrantLock 虽然不能隐式重入，但是获取到锁的线程多次调用 lock 方法，不会阻塞进入同步队列；除此之外在获取锁时支持公平或者非公平的选择。 主要的方法① 构造方法​ 我们可以看出默认的无参是非公平锁，有参构造true表示公平，false表示非公平。 12345678// 无参public ReentrantLock() &#123; sync = new NonfairSync(); &#125;// 有参public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; ② lock() 方法​ 获取锁，其实就是把 state 从 0 变成 n（重入锁可以累加）。 实际调用的是 sync 的 lock 方法，分公平和非公平。 123public void lock() &#123; sync.lock(); &#125; 公平实现​ FairSync，我们发现其实调用的是 acquire，其实这个是 AQS 的 acquire，然后 AQS 的 acquire 的方法里面又会调用 tryAcquire 方法，因为这个方法需要同步组件自己去实现，所以 ReentrantLock 里面重写了 AQS 的 tryAcquire 方法,所以我们获取到锁就会返回 true，没有就会返回 false；然后没有获取到锁的线程就交给 AQS 去处理。 1234567891011121314151617181920212223242526272829303132333435363738static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125; /** * Fair version of tryAcquire. Don&#x27;t grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) &#123; // 获取当前的线程 final Thread current = Thread.currentThread(); // 获取锁的状态 int c = getState(); if (c == 0) &#123; // hasQueuedPredecessors 判断队列还有没有其它 node ,要保证公平 // 没有在用 CAS 设置状态 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; // 设置获取锁的线程 setExclusiveOwnerThread(current); return true; &#125; &#125; // 判断当前线程有没有获取到锁 else if (current == getExclusiveOwnerThread()) &#123; // 获取过了就累加，因为可以重入 int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); // 重新设置锁的状态 setState(nextc); return true; &#125; return false; &#125; &#125; 非公平实现​ NonfairSync ,我们可以发现基本和公平一样，就没有 hasQueuedPredecessors 方法，没有遵循 FIFO队列 的模式，而是不管队列有没有 node，自己都可以去获取锁，不需要排队 12345678910111213141516171819202122232425262728293031323334353637static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125;final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125; ③ lockInterruptibly​ 支持中断的获取锁，其实是调用了 AQS 的 lockInterruptibly 方法，在 AQS 方法里面又回去调用 tryAcquire 方法，这个方法在上面已经解释过了。 12345678910public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125;public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg); &#125; ④ unlock()​ 释放锁，其实就是把 state 从 n（可能发生了锁的重入，需要多次释放）变成 0，这个不区分公平与非公平，首先其实也是调用 AQS 的 release 方法，然后 AQS 在调用子类 Sync 的 tryRelease 方法。 12345678910111213141516171819202122public void unlock() &#123; sync.release(1); &#125; protected final boolean tryRelease(int releases) &#123; // 获取锁的状态 int c = getState() - releases; // 获得锁的线程才能释放锁 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // 直到锁的状态是0，说明锁释放成功，因为有重入锁 // 说明我们在一个线程里面调用几次lock，就要调用几次unlock，才能最终释放锁 if (c == 0) &#123; free = true; // 释放线程的拥有者 setExclusiveOwnerThread(null); &#125; // 设置锁的状态 setState(c); return free;&#125; ReentrantLock 和 Synchronized 的区别相同点：都是可重入锁 不同点： 锁的实现 ：Synchronized 是依赖于 JVM 实现的，而 ReentrantLock 是 JDK 实现的 性能 : 在 Synchronized 优化以前，synchronized 的性能是比 ReentrantLock 差很多的，但是自从 Synchronized 引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用 synchronized，其实synchronized 的优化我感觉就借鉴了 ReentrantLock中的 CAS 技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。 功能 ： 便利性：很明显 Synchronized 的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而 ReentrantLock 需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在 finally 中声明释放锁。 锁的细粒度和灵活度：很明显 ReentrantLock 优于 Synchronized ReentrantLock 独有的能力： 1. ReentrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 2. ReentrantLock 提供了一个 Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像 synchronized 要么随机唤醒一个线程要么唤醒全部线程。 3. ReentrantLock 提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。 ReentrantReadWriteLock介绍​ 在并发场景中用于解决线程安全的问题，我们几乎会高频率的使用到独占式锁，通常使用 java 提供的关键字 synchronized 或者 concurrents 包中实现了 Lock 接口的ReentrantLock。它们都是独占式获取锁，也就是在同一时刻只有一个线程能够获取锁。 ​ 而在一些业务场景中，大部分只是读数据，写数据很少，如果仅仅是读数据的话并不会影响数据正确性（出现脏读），而如果在这种业务场景下，依然使用独占锁的话，很显然这将是出现性能瓶颈的地方。 ​ 针对这种读多写少的情况，java 还提供了另外一个实现 Lock 接口的 ReentrantReadWriteLock (读写锁)。读写所允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞。 ​ 在分析 WirteLock 和 ReadLock 的互斥性时可以按照 WriteLock 与 WriteLock 之间，WriteLock 与 ReadLock 之间以及 ReadLock 与 ReadLock 之间进行分析。更多关于读写锁特性介绍大家可以看源码上的介绍，这里做一个归纳总结： 公平性选择：支持非公平性（默认）和公平的锁获取方式，吞吐量还是非公平优于公平； 重入性：支持重入，读锁获取后能再次获取，写锁获取之后能够再次获取写锁，同时也能够获取读锁； 锁降级：遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁 ​ 要想能够彻底的理解读写锁必须能够理解这样几个问题： 读写锁是怎样实现分别记录读写状态的？ 写锁是怎样获取和释放的？ 读锁是怎样获取和释放的？ 我们带着这样的三个问题，再去了解下读写锁。 写锁写锁的获取​ 同步组件的实现聚合了同步器（AQS），并通过重写重写同步器（AQS）中的方法实现同步组件的同步语义。因此，写锁的实现依然也是采用这种方式。在同一时刻写锁是不能被多个线程所获取，很显然写锁是独占式锁，而实现写锁的同步语义是通过重写 AQS 中的 tryAcquire 方法实现的。源码为: 12345678910111213141516171819202122232425262728293031323334353637protected final boolean tryAcquire(int acquires) &#123; /* * Walkthrough: * 1. If read count nonzero or write count nonzero * and owner is a different thread, fail. * 2. If count would saturate, fail. (This can only * happen if count is already nonzero.) * 3. Otherwise, this thread is eligible for lock if * it is either a reentrant acquire or * queue policy allows it. If so, update state * and set owner. */ Thread current = Thread.currentThread(); // 1. 获取写锁当前的同步状态 int c = getState(); // 2. 获取写锁获取的次数 int w = exclusiveCount(c); if (c != 0) &#123; // (Note: if c != 0 and w == 0 then shared count != 0) // 3.1 当读锁已被读线程获取或者当前线程不是已经获取写锁的线程的话 // 当前线程获取写锁失败 if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error(&quot;Maximum lock count exceeded&quot;); // Reentrant acquire // 3.2 当前线程获取写锁，支持可重复加锁 setState(c + acquires); return true; &#125; // 3.3 写锁未被任何线程获取，当前线程可获取写锁 if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false; setExclusiveOwnerThread(current); return true;&#125; ​ 这段代码的逻辑请看注释，这里有一个地方需要重点关注，exclusiveCount(c) 方法，该方法源码为： 123static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125; ​ 其中 EXCLUSIVE_MASK**为: static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1; EXCLUSIVE _MASK 为 1 左移 16 位然后减 1，即为 0x0000FFFF 。而 exclusiveCount 方法是将同步状态（ state 为 int 类型）与 0x0000FFFF 相与，即取同步状态的低 16 位。那么低 16 位代表什么呢？根据 exclusiveCount 方法的注释为独占式获取的次数即写锁被获取的次数，现在就可以得出来一个结论同步状态的低 16 位用来表示写锁的获取次数**。同时还有一个方法值得我们注意： 123static int sharedCount(int c) &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125; ​ 该方法是获取读锁被获取的次数，是将同步状态（int c）右移 16 次，即取同步状态的高 16 位，现在我们可以得出另外一个结论同步状态的高 16 位用来表示读锁被获取的次数。现在还记得我们开篇说的需要弄懂的第一个问题吗？读写锁是怎样实现分别记录读锁和写锁的状态的，现在这个问题的答案就已经被我们弄清楚了，其示意图如下图所示： ​ 现在我们回过头来看写锁获取方法 tryAcquire，其主要逻辑为：当读锁已经被读线程获取或者写锁已经被其他写线程获取，则写锁获取失败；否则，获取成功并支持重入，增加写状态。 写锁的释放写锁释放通过重写 AQS 的 tryRelease 方法，源码为： 12345678910111213protected final boolean tryRelease(int releases) &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); //1. 同步状态减去写状态 int nextc = getState() - releases; //2. 当前写状态是否为0，为0则释放写锁 boolean free = exclusiveCount(nextc) == 0; if (free) setExclusiveOwnerThread(null); //3. 不为0则更新同步状态 setState(nextc); return free;&#125; ​ 源码的实现逻辑请看注释，不难理解与 ReentrantLock 基本一致，这里需要注意的是，减少写状态 int nextc = getState() - releases; 只需要用当前同步状态直接减去写状态的原因正是我们刚才所说的写状态是由同步状态的低16位表示的。 读锁读锁的获取​ 看完了写锁，现在来看看读锁，读锁不是独占式锁，即同一时刻该锁可以被多个读线程获取也就是一种共享式锁。按照之前对 AQS 介绍，实现共享式同步组件的同步语义需要通过重写 AQS 的 tryAcquireShared 方法和 tryReleaseShared 方法。读锁的获取实现方法为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected final int tryAcquireShared(int unused) &#123; /* * Walkthrough: * 1. If write lock held by another thread, fail. * 2. Otherwise, this thread is eligible for * lock wrt state, so ask if it should block * because of queue policy. If not, try * to grant by CASing state and updating count. * Note that step does not check for reentrant * acquires, which is postponed to full version * to avoid having to check hold count in * the more typical non-reentrant case. * 3. If step 2 fails either because thread * apparently not eligible or CAS fails or count * saturated, chain to version with full retry loop. */ Thread current = Thread.currentThread(); int c = getState(); //1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话，当前 // 线程获取读锁失败返回-1 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; int r = sharedCount(c); if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; //2. 当前线程获取读锁 compareAndSetState(c, c + SHARED_UNIT)) &#123; //3. 下面的代码主要是新增的一些功能，比如getReadHoldCount()方法 //返回当前获取读锁的次数 if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; &#125; return 1; &#125; //4. 处理在第二步中CAS操作失败的自旋已经实现重入性 return fullTryAcquireShared(current);&#125; ​ 代码的逻辑请看注释，需要注意的是 当写锁被其他线程获取后，读锁获取失败，否则获取成功利用 CAS 更新同步状态。另外，当前同步状态需要加上 SHARED_UNIT static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT); //(1 &lt;&lt; SHARED_SHIFT) 即 0x00010000 ​ 原因这是我们在上面所说的同步状态的高 16 位用来表示读锁被获取的次数。如果 CAS 失败或者已经获取读锁的线程再次获取读锁时，是靠 fullTryAcquireShared 方法实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final int fullTryAcquireShared(Thread current) &#123; /* * This code is in part redundant with that in * tryAcquireShared but is simpler overall by not * complicating tryAcquireShared with interactions between * retries and lazily reading hold counts. */ HoldCounter rh = null; for (;;) &#123; int c = getState(); if (exclusiveCount(c) != 0) &#123; if (getExclusiveOwnerThread() != current) return -1; // else we hold the exclusive lock; blocking here // would cause deadlock. &#125; else if (readerShouldBlock()) &#123; // Make sure we&#x27;re not acquiring read lock reentrantly if (firstReader == current) &#123; // assert firstReaderHoldCount &gt; 0; &#125; else &#123; if (rh == null) &#123; rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) &#123; rh = readHolds.get(); if (rh.count == 0) readHolds.remove(); &#125; &#125; if (rh.count == 0) return -1; &#125; &#125; if (sharedCount(c) == MAX_COUNT) throw new Error(&quot;Maximum lock count exceeded&quot;); if (compareAndSetState(c, c + SHARED_UNIT)) &#123; if (sharedCount(c) == 0) &#123; firstReader = current; firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; if (rh == null) rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; cachedHoldCounter = rh; // cache for release &#125; return 1; &#125; &#125; &#125; 读锁的释放读锁释放的实现主要通过方法 tryReleaseShared，源码如下，主要逻辑请看注释： 1234567891011121314151617181920212223242526272829303132protected final boolean tryReleaseShared(int unused) &#123; Thread current = Thread.currentThread(); // 前面还是为了实现getReadHoldCount等新功能 if (firstReader == current) &#123; // assert firstReaderHoldCount &gt; 0; if (firstReaderHoldCount == 1) firstReader = null; else firstReaderHoldCount--; &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); int count = rh.count; if (count &lt;= 1) &#123; readHolds.remove(); if (count &lt;= 0) throw unmatchedUnlockException(); &#125; --rh.count; &#125; for (;;) &#123; int c = getState(); // 读锁释放 将同步状态减去读状态即可 int nextc = c - SHARED_UNIT; if (compareAndSetState(c, nextc)) // Releasing the read lock has no effect on readers, // but it may allow waiting writers to proceed if // both read and write locks are now free. return nextc == 0; &#125;&#125; 锁降级​ 读写锁支持锁降级，遵循按照获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁，不支持锁升级，关于锁降级下面的示例代码摘自 ReentrantWriteReadLock 源码中： 123456789101112131415161718192021222324252627void processCachedData() &#123; rwl.readLock().lock(); if (!cacheValid) &#123; // Must release read lock before acquiring write lock rwl.readLock().unlock(); rwl.writeLock().lock(); try &#123; // Recheck state because another thread might have // acquired write lock and changed state before we did. if (!cacheValid) &#123; data = ... cacheValid = true; &#125; // Downgrade by acquiring read lock before releasing write lock rwl.readLock().lock(); &#125; finally &#123; rwl.writeLock().unlock(); // Unlock write, still hold read &#125; &#125; try &#123; use(data); &#125; finally &#123; rwl.readLock().unlock(); &#125; &#125;&#125; 乐观锁 与 悲观锁介绍 ​ 乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。 悲观锁​ 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如 行锁，表锁等，读锁，写锁 等，都是在做操作之前先上锁。Java中synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。 乐观锁​ 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和 CAS 算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于**write_condition 机制**，其实都是提供的乐观锁。在Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。 两种锁的使用场景​ 从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。 乐观锁常见的两种实现方式 乐观锁一般会使用版本号机制或 CAS 算法实现。 ① 版本号机制​ 一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加 1 。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。 举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 100 。 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 50（ 100 - 50 ）。 在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 20 （ 100 - 20 ）。 操作员 A 完成了修改工作，将数据版本号加 1（ version=2 ），连同帐户扣除后余额（ balance = 50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。 操作员 B 完成了操作，也将版本号加 1（ version=2 ）试图向数据库提交数据（ balance = 80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。 这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。 ② CAS算法​ 即 compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步 （Non-blocking Synchronization）。CAS算法涉及到三个操作数 需要读写的内存值 V 进行比较的值 A 拟写入的新值 B ​ 当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。 乐观锁的缺点 ABA 问题是乐观锁一个常见的问题 ① ABA 问题​ 如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A ，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA” 问题。 ​ JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet() 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 ② 循环时间长开销大​ 自旋 CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给 CPU 带来非常大的执行开销。 如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升。 pause 指令有两个作用： 它可以延迟流水线执行 指令（de-pipeline）,使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。 它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。 ③ 只能保证一个共享变量的原子操作​ CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。所以我们可以使用锁或者利用 AtomicReference 类把多个共享变量合并成一个共享变量来操作。 CAS 与 synchronized 的使用情景 简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少） synchronized适用于写比较多的情况下（多写场景，冲突一般较多） 对于资源竞争较少（线程冲突较轻）的情况，使用 synchronized 同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗 CPU 资源；而 CAS 基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。 对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。 补充：JDK1.6 之后 synchronized 的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和 CAS 类似的性能；而线程冲突严重的情况下，性能远高于 CAS。 公平锁 与 非公平锁公平锁​ 当线程在获取锁的时候，会先判断 Sync 队列中是否有在等待获取资源的线程。若没有，则尝试获取锁，若有，那么就那么就通过 addWaiter 将当前线程封装成 node 结点加入到 Sync 队列中。 非公平锁​ 当线程争夺锁的过程中，会先进行一次 CAS 尝试获取锁，若失败，则进入 acquire(1) 函数，进行一次 tryAcquire 再次尝试获取锁，若再次失败，那么就通过 addWaiter 将当前线程封装成 node 结点加入到 Sync 队列，这时候该线程只能乖乖等前面的线程执行完再轮到自己了。","categories":[{"name":"java基础","slug":"java基础","permalink":"https://www.xiaojianblog.top/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.xiaojianblog.top/tags/java/"}]},{"title":"Java基础-9并发","slug":"Java基础-9并发","date":"2019-07-30T02:31:52.000Z","updated":"2019-08-15T03:07:33.000Z","comments":true,"path":"2019/07/30/Java基础-9并发/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/30/Java%E5%9F%BA%E7%A1%80-9%E5%B9%B6%E5%8F%91/","excerpt":"进程与线程进程​ 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。","text":"进程与线程进程​ 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。 ​ 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。 线程​ 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 并行与并发 并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)； 并行： 单位时间内，多个任务同时执行。 线程详解生命周期和状态状态图 状态 新建( new )：新创建了一个线程对象。 就绪( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start() 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权 。 运行( running )：就绪状态( runnable )的线程获得了 cpu 时间片（ timeslice ），执行程序代码。 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入就绪( runnable )状态，才有机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种： ​ (一). 等待阻塞：运行( running )的线程执行 o.wait() 方法， JVM 会把该线程放 入 等待队列( waitting queue ) 中。 ​ (二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该 同步锁 被别的线程占用，则 JVM 会把该线程放入 锁池( lock pool ) 中。 ​ (三). 其他阻塞: 运行( running )的线程执行 Thread.sleep( long ms ) 或 t.join() 方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。 当 sleep() 状态超时、 join() 等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入就绪( runnable )状态。 死亡( dead )：线程 run() 、 main() 方法执行结束，或者因异常退出了 run() 方法，则该线程结束生命周期。死亡的线程不可再次复生。 线程间的协作sleep() 和 wait() 区别 两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。 两者都可以暂停线程的执行。 wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。 wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。 sleep() 和 yield() 区别 sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield() 方法只会给相同优先级或更高优先级的线程以运行的机会 线程执行 sleep() 方法后转入阻塞（blocked）状态，而执行 yield() 方法后转入就绪（ready）状态 sleep() 方法声明抛出 InterruptedException ，而 yield() 方法没有声明任何异常 stop() 和 suspend() 为何不推荐使用 stop 会导致不安全，为啥呢，如果在同步块执行一半时，stop 来了，后面还没执行完呢，锁没了，线程退出了，别的线程又可以操作你的数据了，所以就是线程不安全了。 suspend 会导致死锁，因为挂起后，是不释放锁的，别人也就阻塞着，如果没人唤醒，那就一直死锁。 线程的使用有三种使用线程的方法： 实现 Runnable 接口； 实现 Callable 接口； 继承 Thread 类。 实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。 实现 Runnable 接口需要实现 run() 方法。 通过 Thread 调用 start() 方法来启动线程。 12345public class MyRunnable implements Runnable &#123; public void run() &#123; // ... &#125;&#125; 12345public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; 实现 Callable 接口与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。 12345public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125; 1234567public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyCallable mc = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get());&#125; 继承 Thread 类同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。 当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。 12345public class MyThread extends Thread &#123; public void run() &#123; // ... &#125;&#125; 1234public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.start();&#125; 实现接口 VS 继承 Thread实现接口会更好一些，因为： Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口； 类可能只要求可执行就行，继承整个 Thread 类开销过大。 多线程​ 并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁 还有受限于硬件和软件的 资源闲置 问题。 上下文切换​ 多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。 ​ 概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。 ​ 上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。 ​ Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。 死锁概念​ 多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。 ​ 如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。 产生死锁的条件 互斥条件：该资源任意一个时刻只由一个线程占用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 避免死锁我们只要破坏产生死锁的四个条件中的其中一个就可以了。 破坏互斥条件 这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。 破坏请求与保持条件 一次性申请所有的资源。 破坏不剥夺条件 占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。 破坏循环等待条件 靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。 线程池简介​ 线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。 这里借用《Java并发编程的艺术》提到的来说一下使用线程池的好处： 降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 创建线程池​ 《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险 Executors 返回线程池对象的弊端如下： FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。 CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。 方式一：通过构造方法实现 Executors 中创建线程池的快捷方法，实际上是调用了 ThreadPoolExecutor 的构造方法（定时任务使用的是 ScheduledThreadPoolExecutor ），该类构造方法参数列表如下： 123456789// Java线程池的完整构造函数public ThreadPoolExecutor( int corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。 int maximumPoolSize, // 线程数的上限 long keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长， // 超过这个时间，多余的线程会被回收。 BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列 ThreadFactory threadFactory, // 新线程的产生方式 RejectedExecutionHandler handler) // 拒绝策略 竟然有7个参数，很无奈，构造一个线程池确实需要这么多参数。这些参数中，比较容易引起问题的有 corePoolSize , maximumPoolSize , workQueue 以及 handler ： corePoolSize 和 maximumPoolSize 设置不当会影响效率，甚至耗尽线程； workQueue : 任务缓存队列 设置不当容易导致OOM (Out Of Memory )； handler: 饱和处理策略 设置不当会导致提交任务时抛出异常。 线程池的工作顺序 corePoolSize -&gt; 任务队列 -&gt; maximumPoolSize -&gt; 拒绝策略 示例1234ExecutorService executorService = new ThreadPoolExecutor(2, 2, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(512), // 使用有界队列，避免OOM new ThreadPoolExecutor.DiscardPolicy()); 明确拒绝任务时的行为任务队列总有占满的时候，这是再 submit() 提交新的任务会怎么样呢？RejectedExecutionHandler 接口为我们提供了控制方式，接口定义如下： 123public interface RejectedExecutionHandler &#123; void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125; 线程池给我们提供了几种常见的拒绝策略： 拒绝策略 拒绝行为 AbortPolicy 抛出RejectedExecutionException DiscardPolicy 什么也不做，直接忽略 DiscardOldestPolicy 丢弃队列中最老的任务 CallerRunsPolicy 将任务分给调用线程来执行 线程池默认的拒绝行为是 AbortPolicy，也就是抛出 RejectedExecutionHandler 异常，该异常是非受检异常，很容易忘记捕获。如果不关心任务被拒绝的事件，可以将拒绝策略设置成 DiscardPolicy ，这样多余的任务会悄悄的被忽略。 1234ExecutorService executorService = new ThreadPoolExecutor(2, 2, 0, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(512), new ThreadPoolExecutor.DiscardPolicy());// 指定拒绝策略 方式二：通过Executor 框架的工具类Executors来实现 我们可以创建三种类型的 ThreadPoolExecutor： FixedThreadPool ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。 SingleThreadExecutor： 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。 CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。 对应Executors工具类中的方法如图所示： 超时时间单个任务的超时时间V Future.get(long timeout, TimeUnit unit) 方法可以指定等待的超时时间，超时未完成会抛出 TimeoutException。 多个任务的超时时间等待多个任务完成，并设置最大等待时间，可以通过 CountDownLatch 完成： 123456789101112131415161718public void testLatch(ExecutorService executorService, List&lt;Runnable&gt; tasks) throws InterruptedException&#123; CountDownLatch latch = new CountDownLatch(tasks.size()); for(Runnable r : tasks)&#123; executorService.submit(new Runnable() &#123; @Override public void run() &#123; try&#123; r.run(); &#125;finally &#123; latch.countDown();// countDown &#125; &#125; &#125;); &#125; latch.await(10, TimeUnit.SECONDS); // 指定超时时间 &#125; 线程池和装修公司​ 以运营一家装修公司做个比喻。公司在办公地点等待客户来提交装修请求；公司有固定数量的正式工以维持运转；旺季业务较多时，新来的客户请求会被排期，比如接单后告诉用户一个月后才能开始装修；当排期太多时，为避免用户等太久，公司会通过某些渠道（比如人才市场、熟人介绍等）雇佣一些临时工（注意，招聘临时工是在排期排满之后）；如果临时工也忙不过来，公司将决定不再接收新的客户，直接拒单。 线程池就是程序中的“装修公司”，代劳各种脏活累活。上面的过程对应到线程池上： 12345678// Java线程池的完整构造函数public ThreadPoolExecutor( int corePoolSize, // 正式工数量 int maximumPoolSize, // 工人数量上限，包括正式工和临时工 long keepAliveTime, TimeUnit unit, // 临时工游手好闲的最长时间，超过这个时间将被解雇 BlockingQueue&lt;Runnable&gt; workQueue, // 排期队列 ThreadFactory threadFactory, // 招人渠道 RejectedExecutionHandler handler) // 拒单方式 总结​ Executors为我们提供了构造线程池的便捷方法，对于服务器程序我们应该杜绝使用这些便捷方法，而是直接使用线程池 ThreadPoolExecutor 的构造方法，避免无界队列可能导致的OOM以及线程个数限制不当导致的线程数耗尽等问题。ExecutorCompletionService 提供了等待所有任务执行结束的有效方式，如果要设置等待的超时时间，则可以通过 CountDownLatch 完成。 CountDownLatch简介用来控制一个或者多个线程等待多个线程。 维护了一个计数器 cnt(count) ，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。 示例1234567891011121314151617public class CountdownLatchExample &#123; public static void main(String[] args) throws InterruptedException &#123; final int totalThread = 10; CountDownLatch countDownLatch = new CountDownLatch(totalThread); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalThread; i++) &#123; executorService.execute(() -&gt; &#123; System.out.print(&quot;run..&quot;); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); System.out.println(&quot;end&quot;); executorService.shutdown(); &#125;&#125; 1run..run..run..run..run..run..run..run..run..run..end ​ 与 CountDownLatch 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 CountDownLatch.await() 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。 ​ 其他N个线程必须引用闭锁对象，因为他们需要通知 CountDownLatch 对象，他们已经完成了各自的任务。这种通知机制是通过 CountDownLatch.countDown() 方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减1。所以当N个线程都调用了这个方法，count 的值等于 0，然后主线程就能通过 await() 方法，恢复执行自己的任务。 CountDownLatch 的不足CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。 CountDownLatch 类中主要的方法 CountDownLatch的概念​ CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步，或者说起到线程之间的通信（而不是用作互斥的作用）。 ​ CountDownLatch 能够使一个线程在等待另外一些线程完成各自工作之后，再继续执行。使用一个计数器进行实现。计数器初始值为线程的数量。当每一个线程完成自己任务后，计数器的值就会减一。当计数器的值为0时，表示所有的线程都已经完成了任务，然后在 CountDownLatch 上等待的线程就可以恢复执行任务。 CountDownLatch的用法 某一线程在开始运行前等待n个线程执行完毕。将 CountDownLatch 的计数器初始化为 n new CountDownLatch(n) ，每当一个任务线程执行完毕，就将计数器减 1 countdownlatch.countDown()，当计数器的值变为0时，在 CountDownLatch 上 await() 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。 实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 CountDownLatch(1) ，将其计数器初始化为 1，多个线程在开始执行任务前首先 coundownlatch.await() ，当主线程调用 countDown() 时，计数器变为0，多个线程同时被唤醒。 CyclicBarrier简介用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。 和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。 CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。 CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。 12345678910public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125;public CyclicBarrier(int parties) &#123; this(parties, null);&#125; 示例1234567891011121314151617181920public class CyclicBarrierExample &#123; public static void main(String[] args) &#123; final int totalThread = 10; CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalThread; i++) &#123; executorService.execute(() -&gt; &#123; System.out.print(&quot;before..&quot;); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.print(&quot;after..&quot;); &#125;); &#125; executorService.shutdown(); &#125;&#125; 1before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after.. 另外，CyclicBarrier 还提供一个更高级的构造函数 CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行 barrierAction，方便处理更复杂的业务场景。示例代码如下： 1234567891011121314151617181920212223public class CyclicBarrierExample &#123; public static void main(String[] args) &#123; final int totalThread = 5; CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread, () -&gt; &#123; System.out.println(&quot;&quot;); System.out.println(&quot;------当线程数达到之后，优先执行------&quot;); &#125;); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalThread; i++) &#123; executorService.execute(() -&gt; &#123; System.out.print(&quot;before..&quot;); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.print(&quot;after..&quot;); &#125;); &#125; executorService.shutdown(); &#125;&#125; 123before..before..before..before..before..------当线程数达到之后，优先执行------after..after..after..after..after.. CyclicBarrier 的应用场景​ CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个Excel的日均银行流水。 CyclicBarrier 和 CountDownLatch 的区别 CountDownLatch：是计数器，只能使用一次，一个或者多个线程，等待其他多个线程完成某件事情之后才能执行； CyclicBarrier：计数器提供reset功能，可以多次使用，多个线程互相等待，直到到达同一个同步点，再继续一起执行。 CountDownLatch CyclicBarrier 减计数方式 加计数方式 计算为0时释放所有等待的线程 计数达到指定值时释放所有等待线程 计数为0时，无法重置 计数达到指定值时，计数置为0重新开始 调用 countDown() 方法计数减1，调用await() 方法只进行阻塞，对计数没任何影响 调用 await() 方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 不可重复利用 可重复利用 Semaphoresynchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。 示例123456789101112131415161718192021222324252627282930313233public class SemaphoreExample1 &#123; // 请求的数量 private static final int threadCount = 550; public static void main(String[] args) throws InterruptedException &#123; // 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢） ExecutorService threadPool = Executors.newFixedThreadPool(300); // 一次只能允许执行的线程数量。 final Semaphore semaphore = new Semaphore(20); for (int i = 0; i &lt; threadCount; i++) &#123; final int threadnum = i; threadPool.execute(() -&gt; &#123;// Lambda 表达式的运用 try &#123; semaphore.acquire();// 获取一个许可，所以可运行线程数量为20/1=20 test(threadnum); semaphore.release();// 释放一个许可 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;); &#125; threadPool.shutdown(); System.out.println(&quot;finish&quot;); &#125; public static void test(int threadnum) throws InterruptedException &#123; Thread.sleep(1000);// 模拟请求的耗时操作 System.out.println(&quot;threadnum:&quot; + threadnum); Thread.sleep(1000);// 模拟请求的耗时操作&#125; ​ 执行 acquire 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 release 方法增加一个许可证，这可能会释放一个阻塞的 acquire 方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。 Semaphore 经常用于限制获取某种资源的线程数量。 当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做： 123semaphore.acquire(5);// 获取5个许可，所以可运行线程数量为20/5=4test(threadnum);semaphore.release(5);// 获取5个许可，所以可运行线程数量为20/5=4 除了 acquire 方法之外，另一个比较常用的与之对应的方法是 tryAcquire 方法，该方法如果获取不到许可就立即返回false。 Semaphore 模式。 公平模式： 调用 acquire 的顺序就是获取许可证的顺序，遵循FIFO； 非公平模式： 抢占式的。 Semaphore 构造方法1234567 public Semaphore(int permits) &#123; sync = new NonfairSync(permits); &#125;// 指定是公平模式还是非公平模式，默认非公平模式public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125; 这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。 Exchanger实现原理​ Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger 用于进行线程间的数据交换。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过 exchange 方法交换数据， 如果第一个线程先执行 exchange 方法，它会一直等待第二个线程也执行 exchange ，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。因此使用 Exchanger 的重点是成对的线程使用 exchange() 方法，当有一对线程达到了同步点，就会进行交换数据。因此该工具类的线程对象是成对的。 Exchanger类提供了两个方法 String exchange(V x) : 用于交换，启动交换并等待另一个线程调用 exchange； String exchange(V x,long timeout,TimeUnit unit) ：用于交换，启动交换并等待另一个线程调用 exchange，并且设置最大等待时间，当等待时间超过 timeout 便停止等待. ThreadLocal简介​ 通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ ​ JDK中提供的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。 ​ 如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。 再举个简单的例子： ​ 比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来避免这两个线程竞争的。 原理从 Thread 类源代码入手。 123456789public class Thread implements Runnable &#123; ......//与此线程有关的ThreadLocal值。由ThreadLocal类维护ThreadLocal.ThreadLocalMap threadLocals = null;//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; ......&#125; ​ 从上面 Thread 类 源代码可以看出 Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为 ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是 null ，只有当前线程调用 ThreadLocal 类的 set() 或 get() 方法时才创建它们，实际上调用这两个方法的时候，我们调用的是 ThreadLocalMap 类对应的 get()、set() 方法。 ThreadLocal.set() 方法 123456789101112 public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; ​ 通过上面这些内容，我们足以通过猜测得出结论：最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap 的封装，传递了变量值。ThrealLocal 类中可以通过Thread.currentThread() 获取到当前线程对象后，直接通过 getMap(Thread t) 可以访问到该线程的 ThreadLocalMap 对象。 ​ 每个Thread中都具备一个 ThreadLocalMap ，而 ThreadLocalMap 可以存储以 ThreadLocal 为 key 的键值对。 ​ 比如我们在同一个线程中声明了两个 ThreadLocal 对象的话，会使用 Thread 内部都是使用仅有那个 ThreadLocalMap 存放数据的，ThreadLocalMap 的 key 就是 ThreadLocal 对象，alue 就是 ThreadLocal 对象调用 set 方法设置的值。 ​ ThreadLocal 是 map 结构是为了让每个线程可以关联多个 ThreadLocal 变量。这也就解释了 ThreadLocal 声明的变量为什么在每一个线程都有自己的专属本地变量。 ThreadLocalMap 是 ThreadLocal 的静态内部类。 内存泄露​ ThreadLocalMap 中使用的 key 为 ThreadLocal 的 弱引用 ,而 value 是 强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候 key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。 ​ ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后最好手动调用remove()方法 123456789 static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 弱引用介绍： ​ 如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 ​ 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。","categories":[{"name":"java基础","slug":"java基础","permalink":"https://www.xiaojianblog.top/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.xiaojianblog.top/tags/java/"}]},{"title":"Java基础-8集合","slug":"Java基础-8集合","date":"2019-07-29T02:31:52.000Z","updated":"2019-08-10T02:08:54.000Z","comments":true,"path":"2019/07/29/Java基础-8集合/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/29/Java%E5%9F%BA%E7%A1%80-8%E9%9B%86%E5%90%88/","excerpt":"前言​ 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。","text":"前言​ 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 Collection Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 List ArrayList：基于动态数组实现，支持随机访问。 Vector：和 ArrayList 类似，但它是线程安全的。 LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 Queue LinkedList：可以用它来实现双向队列。 PriorityQueue：基于堆结构实现，可以用它来实现优先队列。 Map TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 容器中的设计模式迭代器模式 Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。 从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。 123456List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;a&quot;);list.add(&quot;b&quot;);for (String item : list) &#123; System.out.println(item);&#125; 适配器模式java.util.Arrays#asList() 可以把数组类型转换为 List 类型。 12@SafeVarargspublic static &lt;T&gt; List&lt;T&gt; asList(T... a) 应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。 12Integer[] arr = &#123;1, 2, 3&#125;;List list = Arrays.asList(arr); 也可以使用以下方式调用 asList()： 1List list = Arrays.asList(1, 2, 3); 源码分析ArrayList概览因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问，继承了 Serializable 并且申明了 serialVersionUID，表示 ArrayList 是一个可序列化的对象，可以用Bundle 传递 。 1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 12public interface RandomAccess &#123; // 仅做标识&#125; 数组的默认大小为 10。 1private static final int DEFAULT_CAPACITY = 10; 扩容添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 oldCapacity + (oldCapacity &gt;&gt; 1)，也就是旧容量的 1.5 倍。 扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。 123456789101112131415161718192021222324252627282930313233343536373839404142//使用 transient 修饰，该关键字声明字段默认不会被序列化protected transient int modCount = 0; // 用来记录 ArrayList 结构发生变化的次数，下面会详细介绍public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); //DEFAULT_CAPACITY = 10 默认 &#125; ensureExplicitCapacity(minCapacity); // 容量不够，扩容&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 右移相当于 除以2 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 删除元素需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public E remove(int index) &#123; rangeCheck(index); //先进行边界确认，传入的index是否超过了当前数组的大小，如果是抛出异常 modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125;/** * 如果是remove(Object o)，传入的是一个对象，就会进行一次遍历操作，去当前数组中寻找 * 判断是否存在，这里的代码就十分冗余了 * 如果存在就调用 fastRemove 方法 */public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125;//fastRemove(int index)和remove(int index)方法除了边界检查和返回值一模一样private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; Fail-FastmodCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。 在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。 1234567891011121314151617private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util 包下面的所有的集合类都是快速失败的， 而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常。 序列化ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。 保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。 1transient Object[] elementData; // non-private to simplify nested class access ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。 1234567891011121314151617181920private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 1234567891011121314151617private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。 123ArrayList list = new ArrayList();ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));oos.writeObject(list); Vector同步它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。 12345678910111213public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);&#125; 与 ArrayList 的比较 Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制； Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。 替代方案可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。 12List&lt;String&gt; list = new ArrayList&lt;&gt;();List&lt;String&gt; synList = Collections.synchronizedList(list); 也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。 1List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); CopyOnWriteArrayList读写分离写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。 写操作需要加锁，防止并发写入时导致写入数据丢失。 写操作结束之后需要把原始数组指向新的复制数组。 123456789101112131415161718public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125;final void setArray(Object[] a) &#123; array = a;&#125; 1234@SuppressWarnings(&quot;unchecked&quot;)private E get(Object[] a, int index) &#123; return (E) a[index];&#125; 适用场景CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。 但是 CopyOnWriteArrayList 有其缺陷： 内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右； 数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。 所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。 LinkedList概览基于双向链表实现，使用 Node 存储链表节点信息。 12345private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev;&#125; 每个链表存储了 first 和 last 指针： 12transient Node&lt;E&gt; first;transient Node&lt;E&gt; last; 与 ArrayList 的比较 ArrayList 基于动态数组实现，LinkedList 基于双向链表实现； ArrayList 支持随机访问，LinkedList 不支持； LinkedList 在任意位置添加删除元素更快。 HashMap最常用的Map,它根据键的 HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为 Null (多条会覆盖);允许多条记录的值为 Null。非同步的。 以 jdk1.7 为例 存储结构内部包含了一个 Entry 类型的数组 table。 1transient Entry[] table; Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; public final int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; public final String toString() &#123; return getKey() + &quot;=&quot; + getValue(); &#125;&#125; 拉链法的工作原理1234HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(&quot;K1&quot;, &quot;V1&quot;);map.put(&quot;K2&quot;, &quot;V2&quot;);map.put(&quot;K3&quot;, &quot;V3&quot;); 新建一个 HashMap，默认大小为 16； 插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。 插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。 插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。 应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。 查找需要分成两步进行： 计算键值对所在的桶； 在链表上顺序查找，时间复杂度显然和链表的长度成正比。 put 操作1234567891011121314151617181920212223242526public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; // 键为 null 单独处理 if (key == null) return putForNullKey(value); int hash = hash(key); // 确定桶下标 int i = indexFor(hash, table.length); // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // 插入新键值对 addEntry(hash, key, value, i); return null;&#125; HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。 12345678910111213private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null;&#125; 使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。 1234567891011121314151617void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 如果 size 超过 threshold，则扩充 table 大小，再散列 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; // 头插法，链表头部指向新的键值对 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; 123456Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h;&#125; 确定桶下标很多操作都需要先确定一个键值对所在的桶下标。 12int hash = hash(key);int i = indexFor(hash, table.length); 计算 hash 值 1234567891011121314final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 123public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value);&#125; 取模 令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质： 12x : 00010000x-1 : 00001111 令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数： 123y : 10110010x-1 : 00001111y&amp;(x-1) : 00000010 这个性质和 y 对 x 取模效果是一样的： 123y : 10110010x : 00010000y%x : 00000010 我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。 确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。 123static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; 扩容-基本原理设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。 为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。 和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。 参数 含义 capacity table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。 size 键值对数量。 threshold size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。 loadFactor 装载因子，table 能够使用的比例，threshold = capacity * loadFactor。 123456789101112131415static final int DEFAULT_INITIAL_CAPACITY = 16;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;transient Entry[] table;transient int size;int threshold;final float loadFactor;transient int modCount; 从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。 123456void addEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); if (size++ &gt;= threshold) resize(2 * table.length);&#125; 扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。 123456789101112131415161718192021222324252627282930void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor);&#125;void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125;&#125; 扩容-重新计算桶下标在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。 假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32： 12capacity : 00010000new capacity : 00100000 对于一个 Key， 它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样； 如果为 1，那么得到的结果为原来的结果 +16。 计算数组容量HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。 先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到： 123mask |= mask &gt;&gt; 1 11011000mask |= mask &gt;&gt; 2 11111110mask |= mask &gt;&gt; 4 11111111 mask+1 是大于原始数字的最小的 2 的 n 次方。 12num 10010000mask+1 100000000 以下是 HashMap 中计算数组容量的代码： 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 与 HashTable 的比较 线程是否安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）； 效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它； 对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值不能为 null，如果为 null 会抛出 NullPointerException。 初始容量大小和每次扩充容量大小的不同 ： 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2倍。 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2的幂次方 大小（ HashMap 中的 tableSizeFor() 方法保证）。也就是说 HashMap 总是使用 2的幂作 为哈希表的大小。 底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。 和 HashSet区别如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone() 、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。 HashMap HashSet 实现了Map接口 实现Set接口 存储键值对 仅存储对象 调用 put（）向map中添加元素 调用 add（）方法向Set中添加元素 HashMap使用键（Key）计算Hashcode HashSet 使用成员对象来计算 hashCode 值，对于两个对象来说 hashCode 可能相同，所以 equals() 方法用来判断对象的相等性 HashMap JDK 1.8 优化 HashMap 是 数组+链表+红黑树 （JDK 1.8 增加了红黑树部分），当链表长度 &gt;=8 时转化为红黑树。 jdk 1.8 中对 HashMap 扩容不是重新计算所有元素在数组的位置，而是用 2次幂 的扩展（指长度扩为原来的 2倍 ），所以，元素的位置要么在原位置，要么是在原位置再移动 2次幂 的位置。在扩充 HashMap 的时候，不需要像 jdk1.7 的实现那样重新计算 hash ，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成 原索引+oldCap。 HashMap 存放自定义类时，需要实现自定义类的什么方法hashCode 和 equals 。通过 hash(hashCode) 然后模运算（其实是与的位操作）定位在 Entry 数组中的下标，然后遍历这之后链表，通过 equals 比较有没有相同的 key ，如果有直接覆盖 value ，如果没有重新创建一个 Entry 。 HashMap 为什么可以插入空值HashMap 中添加 key==null 的Entry 时会调用 putForNullKey 方法直接去遍历 table[0] 的 Entry 链表，寻找 e.key==null 的 Entry 或者没有找到遍历结束。如果找到了 e.key==null ，就保存 null 值对应的原值 oldValue ，然后覆盖原值，并返回 oldValue 。 Hashmap 为什么线程不安全(hash 碰撞和扩容导致)HashMap 扩容的的时候可能会形成环形链表，造成死循环。 ConcurrentHashMap存储结构123456static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next;&#125; ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁 (Segment)，每个分段锁维护着几个桶 (HashEntry) ，多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。 Segment 继承自 ReentrantLock。表明每个 segment 都可以当做一个锁。这样对每个 segment 中的数据需要同步操作的话都是使用每个 segment 容器对象自身的锁来实现。只有对全局需要改变时锁定的是所有的 segment。 12345678910111213141516static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; private static final long serialVersionUID = 2249069246763182397L; static final int MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1; transient volatile HashEntry&lt;K,V&gt;[] table; transient int count; transient int modCount; transient int threshold; final float loadFactor;&#125; 1final Segment&lt;K,V&gt;[] segments; 默认的并发级别为 16，也就是说默认创建 16 个 Segment。 1static final int DEFAULT_CONCURRENCY_LEVEL = 16; size 操作每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。 12345/** * The number of elements. Accessed only either within locks * or among other volatile reads that maintain visibility. */transient int count; 在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。 ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。 尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。 如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result. */static final int RETRIES_BEFORE_LOCK = 2;public int size() &#123; // Try a few times to get accurate count. On failure due to // continuous async changes in table, resort to locking. final Segment&lt;K,V&gt;[] segments = this.segments; int size; boolean overflow; // true if size overflows 32 bits long sum; // sum of modCounts long last = 0L; // previous sum int retries = -1; // first iteration isn&#x27;t retry try &#123; for (;;) &#123; // 超过尝试次数，则对每个 Segment 加锁 if (retries++ == RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) ensureSegment(j).lock(); // force creation &#125; sum = 0L; size = 0; overflow = false; for (int j = 0; j &lt; segments.length; ++j) &#123; Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null) &#123; sum += seg.modCount; int c = seg.count; if (c &lt; 0 || (size += c) &lt; 0) overflow = true; &#125; &#125; // 连续两次得到的结果一致，则认为这个结果是正确的 if (sum == last) break; last = sum; &#125; &#125; finally &#123; if (retries &gt; RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) segmentAt(segments, j).unlock(); &#125; &#125; return overflow ? Integer.MAX_VALUE : size;&#125; JDK 1.8 的改动JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。 JDK 1.8 的实现已经摒弃了 Segment 的概念，而是直接用 Node数组+链表+红黑树 的数据结构来实现，并发控制使用 Synchronized 和 CAS 来操作，整个看起来就像是优化过且线程安全的 HashMap ，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本。 和 Hashtable 的区别ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。 底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 HashMap 1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的； 实现线程安全的方式（重要）： 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment 的概念，而是直接用 Node 数组+链表+红黑树 的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本； Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。 LinkedHashMap 存储结构继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。 1public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; 内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。 123456789/** * The head (eldest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; head;/** * The tail (youngest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; tail; accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。 1final boolean accessOrder; LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。 12void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;void afterNodeInsertion(boolean evict) &#123; &#125; afterNodeAccess()当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。 123456789101112131415161718192021222324void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; afterNodeInsertion()在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。 evict 只有在构建 Map 的时候才为 false，在这里为 true。 1234567void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125; removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。 123protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; LRU 缓存以下是使用 LinkedHashMap 实现的一个 LRU 缓存： 设定最大缓存空间 MAX_ENTRIES = 3； 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序； 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。 1234567891011class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private static final int MAX_ENTRIES = 3; protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; MAX_ENTRIES; &#125; LRUCache() &#123; super(MAX_ENTRIES, 0.75f, true); &#125;&#125; 123456789public static void main(String[] args) &#123; LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;(); cache.put(1, &quot;a&quot;); cache.put(2, &quot;b&quot;); cache.put(3, &quot;c&quot;); cache.get(1); cache.put(4, &quot;d&quot;); System.out.println(cache.keySet());&#125; 1[3, 1, 4] LinkedHashMap 与 HashMap 的区别 LinkedHashMap 是 HashMap 的子类 LinkedHashMap 中的 Entry 增加了两个指针 before 和 after，它们分别用于维护双向链接列表。 在 put 操作上，虽然 LinkedHashMap 完全继承了 HashMap 的 put 操作，但是在细节上还是做了一定的调整，比如，在 LinkedHashMap 中向哈希表中插入新 Entry 的同时，还会通过Entry 的 addBefore 方法将其链入到双向链表中。 在扩容操作上，虽然 LinkedHashMap 完全继承了 HashMap 的 resize 操作，但是鉴于性能和LinkedHashMap 自身特点的考量，LinkedHashMap 对其中的重哈希过程(transfer 方法)进行了重写 在读取操作上，LinkedHashMap 中重写了 HashMap 中的 get 方法，通过 HashMap 中的 getEntry 方法获取 Entry 对象。在此基础上，进一步获取指定键对应的值。 集合框架底层数据结构总结Collection1. List Arraylist： Object数组 Vector： Object数组 LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环) 2. Set HashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素 LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。 TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。) Map HashMap： JDK1.8之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间 LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。 Hashtable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的 TreeMap： 红黑树（自平衡的排序二叉树）","categories":[{"name":"java基础","slug":"java基础","permalink":"https://www.xiaojianblog.top/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.xiaojianblog.top/tags/java/"}]},{"title":"Java基础-7泛型","slug":"Java基础-7泛型","date":"2019-07-28T12:31:52.000Z","updated":"2019-08-08T10:47:02.000Z","comments":true,"path":"2019/07/28/Java基础-7泛型/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/28/Java%E5%9F%BA%E7%A1%80-7%E6%B3%9B%E5%9E%8B/","excerpt":"Java中的泛型是什么 ? 使用泛型的好处是什么?","text":"Java中的泛型是什么 ? 使用泛型的好处是什么? 这是在各种Java泛型面试中，一开场你就会被问到的问题中的一个，主要集中在初级和中级面试中。那些拥有 Java1.4 或更早版本的开发背景的人都知道，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现 ClassCastException 。 Java的泛型是如何工作的 ? 什么是类型擦除 ? 这是一道更好的泛型面试题。泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如 List&lt;String&gt; 在运行时仅用一个 List 来表示。这样做的目的，是确保能和 Java 5 之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。根据你对这个泛型问题的回答情况，你会得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。请阅读我的Java中泛型是如何工作的来了解更多信息。 什么是泛型中的限定通配符和非限定通配符 ? 这是另一个非常流行的Java泛型面试题。限定通配符对类型进行了限制。有两种限定通配符，一种是 &lt;? extends T&gt; 它通过确保类型必须是T的子类来设定类型的上界，另一种是 &lt;? super T&gt; 它通过确保类型必须是 T 的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面 &lt;?&gt; 表示了非限定通配符，因为 &lt;?&gt; 可以用任意类型来替代。更多信息请参阅我的文章泛型中限定通配符和非限定通配符之间的区别。 List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ? 这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个List的声明都是限定通配符的例子，List&lt;? extends T&gt; 可以接受任何继承自 T 的类型的 List ，而 List&lt;? super T&gt; 可以接受任何 T 的父类构成的 List 。例如 List&lt;? extends Number&gt; 可以接受 List&lt;Integer&gt; 或 List&lt;Float&gt; 。在本段出现的连接中可以找到更多信息。 如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型? 编写泛型方法并不困难，你需要用泛型类型来替代原始类型，比如使用 T , E or K , V 等被广泛认可的类型占位符。泛型方法的例子请参阅Java集合类框架。最简单的情况下，一个泛型方法可能会像这样: 123public V put(K key, V value) &#123; return cache.put(key, value);&#125; Java中如何使用泛型编写带有参数的类? 这是上一道面试题的延伸。面试官可能会要求你用泛型编写一个类型安全的类，而不是编写一个泛型方法。关键仍然是使用泛型类型来代替原始类型，而且要使用JDK中采用的标准占位符。 编写一段泛型程序来实现LRU缓存? 对于喜欢Java编程的人来说这相当于是一次练习。给你个提示，LinkedHashMap 可以用来实现固定大小的LRU 缓存，当 LRU 缓存已经满了的时候，它会把最老的键值对移出缓存。LinkedHashMap 提供了一个称为 removeEldestEntry() 的方法，该方法会被 put() 和 putAll() 调用来删除最老的键值对。当然，如果你已经编写了一个可运行的 JUnit 测试，你也可以随意编写你自己的实现代码。 你可以把List传递给一个接受List参数的方法吗？ 对任何一个不太熟悉泛型的人来说，这个Java泛型题目看起来令人疑惑，因为乍看起来String是一种Object，所以 List&lt;String&gt; 应当可以用在需要 List&lt;Object&gt; 的地方，但是事实并非如此。真这样做的话会导致编译错误。如果你再深一步考虑，你会发现Java这样做是有意义的，因为 List&lt;Object&gt; 可以存储任何类型的对象包括String, Integer等等，而 List&lt;String&gt; 却只能用来存储Strings。 123List&lt;Object&gt; objectList;List&lt;String&gt; stringList;objectList = stringList; //compilation error incompatible types Array中可以用泛型吗? 这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道 Array 事实上并不支持泛型，这也是为什么Joshua Bloch在 Effective Java 一书中建议使用 List 来代替 Array ，因为 List 可以提供编译期的类型安全保证，而 Array 却不能。 如何阻止Java中的类型未检查的警告? 如果你把泛型和原始类型混合起来使用，例如下列代码，Java 5 的 javac 编译器会产生类型未检查的警告，例如 1List&lt;String&gt; rawList = new ArrayList()","categories":[{"name":"java基础","slug":"java基础","permalink":"https://www.xiaojianblog.top/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.xiaojianblog.top/tags/java/"}]},{"title":"AbstractQueuedSynchronizer源码剖析(二)不响应中断的独占锁","slug":"AbstractQueuedSynchronizer源码剖析-二-不响应中断的独占锁","date":"2019-07-28T08:33:11.000Z","updated":"2019-08-27T15:58:36.000Z","comments":true,"path":"2019/07/28/AbstractQueuedSynchronizer源码剖析-二-不响应中断的独占锁/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/28/AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%BA%8C-%E4%B8%8D%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD%E7%9A%84%E7%8B%AC%E5%8D%A0%E9%94%81/","excerpt":"AbstactQueuedSynchronizer的基本数据结构AQS的基本数据结构为 Node","text":"AbstactQueuedSynchronizer的基本数据结构AQS的基本数据结构为 Node 123456789101112131415161718192021222324252627282930313233static final class Node &#123; static final Node SHARED = new Node(); //一个标识位，指示节点使用共享模式等待 static final Node EXCLUSIVE = null; //一个标识位，指示节点使用独占模式等待 static final int CANCELLED = 1; //等待状态值，指示节点使用独占模式等待 static final int SIGNAL = -1; //等待状态值，指示继任的线程需要取消阻塞 static final int CONDITION = -2; //等待状态值，指示线程由于阻塞而处于等待状态 static final int PROPAGATE = -3; //等待状态值，指示处于共享模式下，下一次的acquire需要无条件地传播 volatile int waitStatus; volatile Node prev; //指示当前节点的前驱节点 volatile Node next; //指示当前节点的后继节点 volatile Thread thread; //Node持有的线程，构造方法中初始化，使用完毕之后置为null Node nextWaiter; //指向下一个处于阻塞等待的节点 final boolean isShared() &#123; return nextWaiter == SHARED; &#125; final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; 关于Node，JDK作者写了详细的注释，这里我大致总结几点： AQS 的等待队列是 CLH 队列的变种，CLH 队列通常用于自旋锁，AQS中的 CLH 可以简单的理解为“等待锁的线程队列”。 每个节点中持有一个名为 status 的字段用于一条线程是否应当阻塞的追踪。 一条线程所在节点如果它处于队列头的下一个节点，那么它会尝试去 acquire 。因为头节点是一个 dummy 节点，也就是说头节点不持有任何线程。所以，一条线程所在节点如果它处于队列头节点的下一个节点，那么他会尝试去 acquire ，但是并不保证成功。 要进入队列，你只需要自动将它拼接在队列尾部即可；如果获取了锁，你只需要设置header字段即可。 关于SIGNAL、CANCELLED、CONDITION、PROPAGATE四个状态，JDK源码的注释中同样有了详细的解读，再用一张表格总结一下： 状态 默认值 解读 SIGNAT -1 当前节点的后继节点已经（或者很快会）通过 park 阻塞，因此当当前节点释放或者取消的时候必须 unpark 它的后继节点。为了避免竞争，acquire 方法必须指示为 signal 信号，然后重试原子 acquire 方法，最后在失败的情况下阻塞。 CANCELLED 1 节点因为超时或者被打断而取消，一个节点不会持有这种状态，取消节点持有的线程不会重新阻塞。 CONDITION -2 节点当前处于等待队列中，直到状态在某个时间点被转化为0前它都不会作为同步队列的一个节点被使用。 PROPAGATE -3 共享模式下释放的节点应当被传播到其他节点，这个状态会在doReleaseShared 方法中被设置（只有头结点会设置）来确保传播的持续，即使其他操作介入。 0 不属于上述任何一种。 在“不响应中断的独占锁”模式下AbstractQueuedSynchronizer供子类实现的方法​ AbstractQueuedSynchzonizer 是基于 模板模式 的实现，不过它的模板模式写法有点特别，整个类中没有任何一个 abstract 的抽象方法，取而代之的是，需要子类去实现的那些方法通过一个方法体抛出异常来让子类知道。 方法名 作用 tryAcquire 尝试在独占模式下 acquire ，方法应当查询在独占模式下对象的 state 字段是否允许 acquire ，如果允许，那么可以 acquire 。方法通常在线程执行 acquire 时调用，如果方法失败， acquire 方法会将线程加入等待对列（如果线程还没有加入等待对列），直到它被其他线程发出的信号释放。 tryRelease 尝试在独占模式下设置状态来反映对节点的释放，方法通常在线程执行释放节点时调用 isHeldExclusively 当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程独占 ​ 在这里，读者应该清楚的知道，为什么AQS需要我们去实现这些方法(在这里，我只仅仅说明的是“不响应中断的独占锁”)？在上一篇博客中，我已经提到过，其实AQS只是定义了一个流程而已，关于具体如何获取锁，需要子类实现。 ​ 下面我贴出AQS中的一段代码你就可以明白: 12345public final void acquire(int arg) &#123; //EXCLUSIVE 默认 null; 一个标识位，指示节点使用独占模式等待 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg) ) selfInterrupt();&#125; ​ 这段代码描述的大概意思如下：以独占的方式去获取锁，忽略中断响应。一旦 tryAcquire() 方法执行成功就证明当前线程获取到了锁。子类应该去定制 tryAcquire() 方法的具体实现。 在“不响应中断的独占锁”模式下AbstractQueuedSynchronizer获取锁的实现流程​ tryAcquire 方法前面说过了，是子类实现的一个方法，如果 tryAcquire 返回的是 true ，即表明当前线程获得了锁，自然也就不需要构建数据结构进行阻塞等待。如果 tryAcquire 方法返回的是 false ，那么当前线程没有获得锁，接着执行 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 这句代码，这句话很明显，它是由两步构成的： addWaiter(Node.EXCLUSIVE), arg) ，将当前线程封装成一个节点，添加到“等待锁的线程队列”中去。 acquireQueued ，当前线程所在节点目前在“等待锁的线程队列”中，当前线程仍然尝试从等待队列中去获取锁。 addWaiter(Node.EXCLUSIVE), arg)流程12345678910111213141516private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; // 快速入队 if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; // 初始化“等待锁的线程队列CLH” enq(node); return node;&#125; ​ 我们知道，在当前我们分析的这种情况下，我们给 addWaiter 传递的参数是 Node.EXCLUSIVE ，从传入的参数我们知道这是独占模式的。并且获取当前线程 thread，将当前线程 thread 以及 EXCLUSIVE 独占模式，构造成一个节点 Node 。构造完成之后，需要入队，即加入到“等待锁的线程队列CLH”中。 ​ 如何入队？首先尝试的是快速入队。何为快速入队？直接把我们刚才构造的node的前驱指针指向当前尾节点，然后通过CAS操作把我们刚才构造的node作为新的尾节点，最后再把原来老的尾节点的后继指针指向现在的新的尾节点。说了那么多，那么快速入队的大前提是什么？那就是这个“等待锁的线程队列CLH”必须先存在。如果不存在，那么只能走常规的入队操作流程，也就是进入到 enq(node) 方法中。从这里我们也可以知道，其实enq(node) 在AQS的整个生命周期中只会执行一次，因为只有第一次初始化“等待锁的线程队列CLH”才会走到这里，后来的入队都会走“快速入队”流程。 ​ 假设我们这里还没有“等待锁的线程队列CLH”，即当前的 tail 节点为 null ，那么就会进入 enq(node) 方法。 下面我们看下 enq(node) 方法的源代码： 123456789101112131415private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; ​ 逻辑为：如果尾节点为空，即当前数据结构中没有节点，那么 new 一个不带任何状态的 Node 作为头节点，并且将 head 赋值给 tail 。如果尾节点不为空，那么并发下使用 CAS 算法将当前 Node 追加成为尾节点，由于是一个for(;;)循环，因此所有没有成功 acquire 的 Node 最终都会被追加到数据结构中。 acquireQueued(final Node node, int arg)流程​ 刚才我们分析 addWaiter(Node.EXCLUSIVE), arg) 流程，知道了当前线程已经被封装成了 Node 节点加入到了“等待锁的线程队列CLH”中了，但是当前线程目前还没有阻塞。那么它是什么时候应该阻塞呢？它在阻塞之前应该做些什么呢？下面我们具体分析。 来看下 acquireQueued(final Node node, int arg) 源码 1234567891011121314151617181920final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; ​ OK，通过前面的分析，我们知道如果通过 tryAcquire 获取失败之后，就会进入到 addWaiter(Node.EXCLUSIVE), arg) 流程，进而进入到 acquireQueued(final Node node, int arg) 流程。进入到这个流程，就说明了该线程在之前是获取资源失败的，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。没错，就是这样！但是在休息之前，该线程还是不泄气，它还是想再争取一次。 ​ 情况一：通过第6行代码可以看出，如果当前线程所在节点的前继节点是head节点，那么当前节点就再次的tryAcquire 了一次。如果当前线程所在节点 tryAcquire 成功了，那么执行 setHead 方法，将当前节点作为head 、将当前节点中的 thread 设置为 null 、将当前节点的 prev 设置为 null ，这保证了数据结构中头结点永远是一个不带 Thread 的空节点。为什么需要判断当前线程所在节点的前继节点是 head 节点，就再次的去 tryAcquire 了一次呢？ ​ 情况二：如果当前线程所在节点的前继节点不是 head 节点，那么它就需要判断自己需不需要进行阻塞了，因为至少到目前为止，它真的没有机会再去获取锁了。当前线程进行阻塞的大前提是，需要寻找一个前继节点的 waitStatus 为 SIGNAL 的节点，这是AQS约定的。只有自己节点的前继节点的 waitStatus 是 SIGNAL ，我这个节点才可以安心的去阻塞。因为我的前继节点的 waitStatus 是 SIGNAL ，就相当于我告诉了我的前继节点，我将要去阻塞了，到时候请唤醒我。 请看 shouldParkAfterFailedAcquire(Node pred, Node node) 源码 1234567891011121314private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) return true; if (ws &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 这里会判断当前节点的前驱节点的状态，如果 如果当前节点的前驱节点的 waitStatus 是 SIGNAL ，返回 true ，表示当前节点应当 park 。这个时候就会调用 parkAndCheckInterrupt() 方法： 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; ​ 当前线程就会被阻塞住。从这个方法还可以看出，如果这个线程被唤醒了，这个线程自己会返回在它阻塞期间有没有被中断过。需要注意的是，Thread.interrupted() 会清除当前线程的中断标记位。所以在这里我们可以明白，在 acquireQueued(final Node node, int arg) 方法中，如果这个线程被唤醒了，并且曾经在阻塞期间被中断过，就将中断标识符 interrupted 置为 true 。接着线程又会进入 acquireQueued(final Node node, int arg) 的for循环中。如果当前这个被唤醒的线程是正常被唤醒的，那么它的前继节点就应该是 head ，这个时候当前被唤醒的线程就会执行 tryAcquire 方法去获取锁。如果假设它获取锁成功了，那么它会把自己设置为 head 节点，并且把 head 节点的持有线程设置为 null ，以保持 head 节点是 dummy 节点，接着当前线程就去做自己的业务了。 如果当前节点的前驱节点的 waitStatus&gt;0 ，相当于 CANCELLED （因为状态值里面只有CANCELLED是大于0的），那么 CANCELLED 的节点作废，当前节点不断向前找并重新连接为双向队列，直到找到一个前驱节点waitStats 不是 CANCELLED 的并且最靠近 head 节点的那一个为止。它的前驱节点不是 SIGNAL 状态且 waitStatus&lt;=0 ，利用CAS机制把前驱节点的 waitStatus 更新为 SIGNAL 状态。在这种情况下 parkAndCheckInterrupt 返回的是 false ，也就是说当前节点持有的线程还是不死心，它还需要最后一次 tryAcquire ，这也是它最后的一次挣扎的机会了。如果这一次失败了，就必须进行阻塞。 通过上面的分析，再来总结下它的流程吧，我们接下来再回到acquire()！再贴上它的源码吧 12345public final void acquire(int arg) &#123; //EXCLUSIVE 默认 null; 一个标识位，指示节点使用独占模式等待 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg) ) selfInterrupt();&#125; 调用自定义同步器的 tryAcquire 尝试直接去获取资源，如果成功则直接返回； 没成功，则 addWaiter 将该线程加入等待队列的尾部，并标记为独占模式； acquireQueued 使线程在等待队列中休息，有机会时（轮到自己，会被 unpark() ）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。 如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断 selfInterrupt() ，将中断补上。由于此函数是重中之重，我再用流程图总结一下： 至此，acquire 的流程终于算是告一段落了。这也就是 ReentrantLock.lock() 的流程，整个函数就是一条acquire(1) ！！！ 在“不响应中断的独占锁”模式下AbstractQueuedSynchronizer释放锁流程​ 上一小节已经把 acquire() 说完了，这一小节就来讲讲它的反操作 release() 吧。此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即 state=0 ）,它会唤醒等待队列里的其他线程来获取资源。下面是 release() 的源码： 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; ​ 逻辑并不复杂。它调用 tryRelease 来释放资源。有一点需要注意的是，它是根据 tryRelease 的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计 tryRelease 的时候要明确这一点！！跟 tryAcquire 一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease 都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可 (state-=arg) ，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release 是根据 tryRelease 的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在实现时，如果已经彻底释放资源(state=0)，要返回 true，否则返回 false 。如果没有彻底释放资源，也就是出现了重入的情况，需要多次释放。如果释放成功了，我们就需要唤醒head节点的下一个节点所持有的线程。 ​ 基本逻辑如下: 首先拿到 head 节点，判断 head 节点不等于 null ，并且 head 节点的 waitStatus 是不等于0的话，就去唤醒 head 节点的下一个节点所持有的线程。 调用 unparkSuccessor(Node node) 方法唤醒 head 节点的下一个节点所持有的线程。接下来看下 unparkSuccessor(Node node) 方法的源代码： 12345678910111213141516private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; ​ 这个函数并不复杂。一句话概括：用 unpark() 唤醒等待队列中最前边的那个未放弃的线程，这里我们也用 s 来表示吧。此时，再和 acquireQueued() 联系起来，s 被唤醒后，进入 if (p == head &amp;&amp; tryAcquire(arg)) 的判断（即使 p!=head 也没关系，它会再进入 shouldParkAfterFailedAcquire() 寻找一个安全点。这里既然 s 已经是等待队列中最前边的那个未放弃的线程了，那么通过 shouldParkAfterFailedAcquire() 的调整，s 也必然会跑到 head 的 next 结点，下一次自旋 p==head 就成立啦），然后 s 把自己设置成 head 标杆结点，表示自己已经获取到资源了，acquire() 也返回了！","categories":[{"name":"AQS","slug":"AQS","permalink":"https://www.xiaojianblog.top/categories/AQS/"}],"tags":[{"name":"AQS源码","slug":"AQS源码","permalink":"https://www.xiaojianblog.top/tags/AQS%E6%BA%90%E7%A0%81/"}]},{"title":"Java基础-6反射","slug":"Java基础-6反射","date":"2019-07-28T07:31:52.000Z","updated":"2019-08-08T10:46:40.000Z","comments":true,"path":"2019/07/28/Java基础-6反射/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/28/Java%E5%9F%BA%E7%A1%80-6%E5%8F%8D%E5%B0%84/","excerpt":"什么是Java类中的反射？","text":"什么是Java类中的反射？ ​ 当程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。我们认为 Java 并不是动态语言，但是它却又一个非常突出的动态相关的机制，俗称：反射。 Reflection 是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类和对象的内部属性。 Oracle 官方对反射解释： ​ Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions. ​ The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control. ​ 通过反射，我们可以在运行时获得程序或程序集中每一个类型成员和成员变量的信息。 程序中一般的对象类型都是在编译期就确定下来的，而Java 反射机制可以动态的创建对象并调用其属性，这样对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象即使这个对象在编译期是未知的， 反射的核心：是 JVM 在运行时 才动态加载的类或调用方法或属性，他不需要事先（写代码的时候或编译期）知道运行对象是谁。 Java反射框架提供以下功能： ①、在运行时判断任意一个对象所属的类②、在运行时构造任意一个类的对象③、在运行时判断任意一个类所具有的成员变量和方法（通过反射设置可以调用 private）④、在运行时调用人一个对象的方法 重点：是运行时而不是编译时 反射的主要用途​ 很多人都认为反射在实际Java中开发应用中并不广泛，其实不然。 当我们在使用 IDE（如 Eclipse\\IDEA）时，当我们输入一个队长或者类并向调用它的属性和方法时，一按 (“.”)点号，编译器就会自动列出她的属性或方法，这里就会用到反射。 反射最重要的用途就是开发各种通用框架。​ 很多框架（比如 Spring）都是配置化的（比如通过 XML文件配置 JavaBean，Action之类的），为了保证框架的通用性，他们可能根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。 举一个例子，在运用Struts 2框架的开发中我们一般会在 struts.xml 里去配置 Action，比如： 123456&lt;action name=&quot;login&quot; class=&quot;org.ScZyhSoft.test.action.SimpleLoginAction&quot; method=&quot;execute&quot;&gt; &lt;result&gt;/shop/shop-index.jsp&lt;/result&gt; &lt;result name=&quot;error&quot;&gt;login.jsp&lt;/result&gt; &lt;/action&gt; ​ 配置文件与Action建立了一种映射关系，当View层发出请求时，请求会被 StrutsPrepareAndExecuteFilter 拦截，然后 StrutsPrepareAndExecuteFilter 会去动态地创建 Action 实例。 比如我们请求 login.action ，那么 StrutsPrepareAndExecuteFilter 就会去解析 struts.xml 文件，检索action 中 name 为 login 的 Action ，并根据 class 属性创建 SimpleLoginAction 实例，并用 invoke 方法来调用 execute 方法，这个过程离不开反射。 对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。 反射的基本运用​ 以上我们提到了反射可以拟用于判断任意对象所属的类，获得 Class对象，构造人一个对象以及调用一个对象。这里我们介绍一下基本反射功能的事先（反射相关类一般都在 java.lang.relfect 包里）。 获得 Class 对象 使用 Class类的 forName() 静态方法： 12345public static Class&lt;?&gt; forName(String className)……在JDBC开发中常用此方法加载数据库驱动:……javaClass.forName(driver) 直接获取某一个对象的 class，比如： 12Class&lt;?&gt; klass = int.class;Class&lt;?&gt; classInt = Integer.TYPE; 调用某个对象的getClass() 方法，比如： 12StringBuilder str = new StringBuilder(&quot;123&quot;);Class&lt;?&gt; klass = str.getClass(); 判断是否为某个类的实例​ 一般地，我们用 instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的 isInstance() 方法来判断是否为某个类的实例，它是一个 Native 方法： 1public native boolean isInstance(Object obj); 创建实例通过反射来生成对象主要有两种方式。 （1）、使用 Class 对象的 newInstance() 方法来创建对象对应类的实例。 12Class&lt;?&gt; c = String.calss;Object str = c.getInstance(); （2）、先通过 Class 对象获取制定的 Constructor 对象，在调用 Constructor 对象的 newInstance() 方法来创建实例。这种方法可以用指定的构造器构造类的实例。 1234567//获取String所对应的Class对象 Class&lt;?&gt; c = String.class;//获取String类带一个String参数的构造器Constructor constructor = c.getConstructor(String.class);//根据构造器创建实例Object obj = constructor.newInstance(&quot;23333&quot;);System.out.println(obj); 获取方法​ 获取某个 Class 对象的方法集合，主要有以下几个方法： getDeclaredMethods() 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 1public Method[] getDeclaredMethods() throws SecurityException ​ getMethods() 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。 1public Method[] getMethods() throws SecurityException ​ getMethod 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象 1public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 只是这样描述的话可能难以理解，我们用例子来理解这三个方法： 1234567891011121314151617181920212223242526272829public class test1 &#123; public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; Class&lt;?&gt; c = methodClass.class; Object object = c.newInstance(); Method[] methods = c.getMethods(); Method[] declaredMethods = c.getDeclaredMethods(); //获取methodClass类的add方法 Method method = c.getMethod(&quot;add&quot;, int.class, int.class); //getMethods()方法获取的所有方法 System.out.println(&quot;getMethods获取的方法：&quot;); for(Method m:methods)&#123; System.out.println(m); &#125; //getDeclaredMethods()方法获取的所有方法 System.out.println(&quot;getDeclaredMethods获取的方法：&quot;); for(Method m:declaredMethods)&#123; System.out.println(m); &#125; &#125;&#125;class methodClass &#123; public final int fuck = 3; public int add(int a,int b) &#123; return a+b; &#125; public int sub(int a,int b) &#123; return a+b; &#125;&#125; 程序运行的结果如下: 123456789101112131415getMethods获取的方法：public int com.shengsiyuan.zerocopy.methodClass.add(int,int)public int com.shengsiyuan.zerocopy.methodClass.sub(int,int)public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic boolean java.lang.Object.equals(java.lang.Object)public java.lang.String java.lang.Object.toString()public native int java.lang.Object.hashCode()public final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll()getDeclaredMethods获取的方法：public int com.shengsiyuan.zerocopy.methodClass.add(int,int)public int com.shengsiyuan.zerocopy.methodClass.sub(int,int) ​ 可以看到，通过 getMethods() 获取的方法可以获取到父类的方法,比如 java.lang.Object 下定义的各个方法。 获取构造器信息​ 获取类构造器的用法与上述获取方法的用法类似。主要是通过 Class 类的 getConstructor 方法得到Constructor 类的一个实例，而 Constructor类有一个 newInstance 方法可以创建一个对象实例: 1public T newInstance(Object ... initargs) ​ 此方法可以根据传入的参数来调用对应的 Constructor 创建对象实例~ 获取类的成员变量（字段）信息 主要是这几个方法，在此不再赘述：getFiled: 访问公有的成员变量getDeclaredField：所有已声明的成员变量。但不能得到其父类的成员变量getFileds 和 getDeclaredFields 用法同上（参照Method） 调用方法当我们从类中获取了一个方法后，我们就可以用 invoke() 方法来调用这个方法。invoke方法的原型为: 1public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException 下面是一个实例： 1234567891011121314151617public class test &#123; public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; Class&lt;?&gt; klass = methodClass.class; //创建methodClass的实例 Object obj = klass.newInstance(); //获取methodClass类的add方法 Method method = klass.getMethod(&quot;add&quot;,int.class,int.class); //调用method对应的方法 =&gt; add(1,4) Object result = method.invoke(obj,1,4); System.out.println(result); // 5 &#125;&#125;class methodClass &#123; public int add(int a,int b) &#123; return a+b; &#125;&#125; 利用反射创建数组​ 数组在Java里是比较特殊的一种类型，它可以赋值给一个Object Reference。下面我们看一看利用反射创建数组的例子： 123456789101112public static void testArray() throws ClassNotFoundException &#123; Class&lt;?&gt; cls = Class.forName(&quot;java.lang.String&quot;); Object array = Array.newInstance(cls,25); //往数组里添加内容 Array.set(array,0,&quot;hello&quot;); Array.set(array,1,&quot;Java&quot;); Array.set(array,2,&quot;zhangsan&quot;); Array.set(array,3,&quot;lisi&quot;); Array.set(array,4,&quot;wangwu&quot;); //获取某一项的内容 System.out.println(Array.get(array,3)); &#125; ​ 其中的Array类为 java.lang.reflect.Array 类。我们通过 Array.newInstance() 创建数组对象，它的原型是: 123public static Object newInstance(Class&lt;?&gt; componentType, int length) throws NegativeArraySizeException &#123; return newArray(componentType, length);&#125; 反射的一些注意事项​ 由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。 另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。","categories":[{"name":"java基础","slug":"java基础","permalink":"https://www.xiaojianblog.top/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.xiaojianblog.top/tags/java/"}]},{"title":"Java基础-5关键字","slug":"Java基础-5关键字","date":"2019-07-28T05:31:52.000Z","updated":"2019-08-08T10:46:26.000Z","comments":true,"path":"2019/07/28/Java基础-5关键字/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/28/Java%E5%9F%BA%E7%A1%80-5%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"final1. 数据 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。","text":"final1. 数据 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 1234final int x = 1;// x = 2; // cannot assign value to final variable &#x27;x&#x27;final A y = new A();y.a = 1; 2. 方法 声明方法不能被子类重写。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3. 类 声明类不允许被继承。 4.finalize、 finalization、 finally finalize 用途 垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的 finalize() 方法但是在Java 中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说 filalize() 可能永远不被执行，显然指望它做收尾工作是靠不住的。那么 finalize() 究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java 程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种 JNI(Java Native Interface) 调用 non-Java程序（C 或C++），finalize() 的工作就是回收这部分的内存。 finally finally 到底在 return之前执行还是之后呢？推荐一个漫画介绍 finally 一定会被执行，如果 finally 里有 return 语句，则覆盖 try/catch 里的 return ，比较爱考的是 finally 里没有 return 语句，这时虽然 finally 里对 return 的值进行了修改，但 return 的值并不改变这种情况。 public class TestTryCatch &#123; public static void main(String[] args) &#123; TestTryCatch test = new TestTryCatch(); System.out.println(&quot;输出结果：&quot; + test.fun()); &#125; public int fun() &#123; int i = 10; try &#123; //doing something return i; &#125;catch(Exception e)&#123; return i; &#125;finally&#123; i = 20; &#125; &#125; &#125; 123```java输出结果：10 当finally调用的任何可变API， return 的值会改变; public class TestTryCatch &#123; public static void main(String[] args) &#123; TestTryCatch test = new TestTryCatch(); System.out.println(&quot;输出结果：&quot; + test.fun()); &#125; public StringBuilder fun() &#123; StringBuilder s = new StringBuilder(&quot;Hello&quot;); try &#123; //doing something s.append(&quot;Word&quot;); return s; &#125;catch(Exception e)&#123; return s; &#125;finally&#123; s.append(&quot;Finally&quot;); &#125; &#125; &#125; 123```java输出结果：HelloWordFinally 在声明方法是我们声明了返回值类型。那么编译器就会在代码的最前端预留一段返回值类型的内存。执行 return 的时候，就会把返回的内容写入到这段内存中; 在执行了 return 之后，返回的值已经被写入到那段内存中了，finally 再修改 i 的值，只是修改了后面代码段的 i 值，对返回段内存没有影响; 当返回值不是基本数据类型的时候，其是指向一段内存的，return 将返回段指向一段内存，但是代码段的 s 依然是指向的同一段内存地址，所以当 s 修改它指向内存中的值的时候，其实也就修改了返回段指向内存中的值，所以最终的值改变了。 到底返回值变不变可以简单的这么记忆：当 finally 调用的任何可变 API ，会修改返回值；当finally 调用任何的不可变 API ，对返回值没有影响。 finally 代码块和 finalize() 方法有什么区别？ 无论是否抛出异常，finally 代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object 类的一个 protected 方法，它是在对象被垃圾回收之前由Java 虚拟机来调用的。 static1. 静态变量 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 123456789101112public class A &#123; private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) &#123; // int x = A.x; // Non-static field &#x27;x&#x27; cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; &#125;&#125; 2. 静态方法 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 1234567891011public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // Non-static field &#x27;y&#x27; cannot be referenced from a static context // int b = this.y; // &#x27;A.this&#x27; cannot be referenced from a static context &#125;&#125; 3. 静态语句块 静态语句块在类初始化时运行一次。 12345678910public class A &#123; static &#123; System.out.println(&quot;123&quot;); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125; 1123 4. 静态内部类 非静态内部类依赖于外部类的实例，而静态内部类不需要。 123456789101112131415public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 1import static com.xxx.ClassName.* 6. 初始化顺序 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 1public static String staticField = &quot;静态变量&quot;; 123static &#123; System.out.println(&quot;静态语句块&quot;);&#125; 1public String field = &quot;实例变量&quot;; 123&#123; System.out.println(&quot;普通语句块&quot;);&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println(&quot;构造函数&quot;);&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数）","categories":[{"name":"java基础","slug":"java基础","permalink":"https://www.xiaojianblog.top/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.xiaojianblog.top/tags/java/"}]},{"title":"Java基础-4Object的通用方法","slug":"Java基础-4Object的通用方法","date":"2019-07-28T02:31:52.000Z","updated":"2019-08-08T10:46:11.000Z","comments":true,"path":"2019/07/28/Java基础-4Object的通用方法/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/28/Java%E5%9F%BA%E7%A1%80-4Object%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"概览","text":"概览 123456789101112131415161718192021public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native Class&lt;?&gt; getClass()protected void finalize() throws Throwable &#123;&#125;public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedException equals()1. 等价关系 Ⅰ 自反性 1x.equals(x); // true Ⅱ 对称性 1x.equals(y) == y.equals(x); // true Ⅲ 传递性 12if (x.equals(y) &amp;&amp; y.equals(z)) x.equals(z); // true; Ⅳ 一致性 多次调用 equals() 方法结果不变 1x.equals(y) == x.equals(y); // true Ⅴ 与 null 的比较 对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false 1x.equals(null); // false; 2. 等价与相等 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。 1234Integer x = new Integer(1);Integer y = new Integer(1);System.out.println(x.equals(y)); // trueSystem.out.println(x == y); // false 3. 实现 检查是否为同一个对象的引用，如果是直接返回 true； 检查是否是同一个类型，如果不是，直接返回 false； 将 Object 对象进行转型； 判断每个关键域是否相等。 123456789101112131415161718192021222324public class EqualExample &#123; private int x; private int y; private int z; public EqualExample(int x, int y, int z) &#123; this.x = x; this.y = y; this.z = z; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; EqualExample that = (EqualExample) o; if (x != that.x) return false; if (y != that.y) return false; return z == that.z; &#125;&#125; hashCode()hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。 下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hashCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。 1234567EqualExample e1 = new EqualExample(1, 1, 1);EqualExample e2 = new EqualExample(1, 1, 1);System.out.println(e1.equals(e2)); // trueHashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();set.add(e1);set.add(e2);System.out.println(set.size()); // 2 理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。 一个数与 31 相乘可以转换成移位和减法：31*x == (x&lt;&lt;5)-x，编译器会自动进行这个优化。 12345678@Overridepublic int hashCode() &#123; int result = 17; result = 31 * result + x; result = 31 * result + y; result = 31 * result + z; return result;&#125; toString()默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 12345678public class ToStringExample &#123; private int number; public ToStringExample(int number) &#123; this.number = number; &#125;&#125; 12ToStringExample example = new ToStringExample(123);System.out.println(example.toString()); //ToStringExample@4554617c clone()1. cloneable clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。 1234public class CloneExample &#123; private int a; private int b;&#125; 12CloneExample e1 = new CloneExample();// CloneExample e2 = e1.clone(); // &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27; 重写 clone() 得到以下实现： 123456789public class CloneExample &#123; private int a; private int b; @Override public CloneExample clone() throws CloneNotSupportedException &#123; return (CloneExample)super.clone(); &#125;&#125; 123456CloneExample e1 = new CloneExample();try &#123; CloneExample e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125; 1java.lang.CloneNotSupportedException: CloneExample 以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。 应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。 123456789public class CloneExample implements Cloneable &#123; private int a; private int b; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 2. 浅拷贝 拷贝对象和原始对象的引用类型引用同一个对象。 123456789101112131415161718192021222324public class ShallowCloneExample implements Cloneable &#123; private int[] arr; public ShallowCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected ShallowCloneExample clone() throws CloneNotSupportedException &#123; return (ShallowCloneExample) super.clone(); &#125;&#125; 123456789ShallowCloneExample e1 = new ShallowCloneExample();ShallowCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 222 3. 深拷贝 拷贝对象和原始对象的引用类型引用不同对象。 1234567891011121314151617181920212223242526272829public class DeepCloneExample implements Cloneable &#123; private int[] arr; public DeepCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected DeepCloneExample clone() throws CloneNotSupportedException &#123; DeepCloneExample result = (DeepCloneExample) super.clone(); result.arr = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; result.arr[i] = arr[i]; &#125; return result; &#125;&#125; 123456789DeepCloneExample e1 = new DeepCloneExample();DeepCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 2 4. clone() 的替代方案 使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。 1234567891011121314151617181920212223242526public class CloneConstructorExample &#123; private int[] arr; public CloneConstructorExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public CloneConstructorExample(CloneConstructorExample original) &#123; arr = new int[original.arr.length]; for (int i = 0; i &lt; original.arr.length; i++) &#123; arr[i] = original.arr[i]; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125;&#125; 1234CloneConstructorExample e1 = new CloneConstructorExample();CloneConstructorExample e2 = new CloneConstructorExample(e1);e1.set(2, 222);System.out.println(e2.get(2)); // 2","categories":[{"name":"java基础","slug":"java基础","permalink":"https://www.xiaojianblog.top/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.xiaojianblog.top/tags/java/"}]},{"title":"Java基础-3String","slug":"Java基础-3String","date":"2019-07-27T09:31:52.000Z","updated":"2019-08-25T16:11:59.000Z","comments":true,"path":"2019/07/27/Java基础-3String/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/27/Java%E5%9F%BA%E7%A1%80-3String/","excerpt":"String、 StringBuffer、 StringBuilder 的区别","text":"String、 StringBuffer、 StringBuilder 的区别 1. 可变性 String 长度不可变 StringBuffer 和 StringBuilder 长度是可变的可变 2. 线程安全 String 不可变，因此是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 StringBuilder 不是线程安全的，所以比 StringBuffer 拥有更好的性能 String 值不可变？ final？ final 首先因为 String 不可变，如果 String 不是 final ，那么就可以有子类继承 String 类，然后子类覆盖其方法，使得这些方法可以修改字符串，这样就违背了 String 的不可变性。 不可变的原因 字符串池（String pool）的需求在Java中，当初始化一个字符串变量时，如果字符串已经存在，就不会创建一个新的字符串变量，而是返回存在字符串的引用。例如： String string1=&quot;abcd&quot;; `String string2=&quot;abcd&quot;;` 这两行代码在堆中只会创建一个字符串对象。如果字符串是可变的，改变另一个字符串变量，就会使另一个字符串变量指向错误的值。 缓存字符串hashcode码的需要 字符串的hashcode是经常被使用的，字符串的不变性确保了hashcode的值一直是一样的，在需要hashcode时，就不需要每次都计算，这样会很高效。 出于安全性考虑 字符串经常作为网络连接、数据库连接等参数，不可变就可以保证连接的安全性。 String 中的 hashcode 以及 toStringString 有重写 Object 的 hashcode 和 toString ？如果重写 equals 不重写 hashcode 会出现什么问题？ String有重写Object的 hashcode 和 toString 吗？ String重写了Object类的 hashcode 和 toString 方法。 当equals方法被重写时，通常有必要重写 hashcode 方法，以维护 hashcode 方法的常规协定，该协定声明相对等的两个必须有相同的 hashcode。 object1.equals(object2) 为true时, object1.hashCode() == object2.hashCode() 为true。 object1.hashCode() == object2.hashCode() 为fasle时，object1.equals(object2) 必定为false。 object1.hashCode() == object2.hashCode() 为true时， object1.equals(object2) 不一定为true。 重写equals不重写hashcode会出现什么问题 在存储散列集合时(如 Set 类)，如果原对象.equals(新对象)，但没有对 hashCode 重写，即两个对象拥有不同的hashcode，则在集合中将会存储两个值相同的对象，从而导致混淆。因此在重写 equals 方法时，必须重写 hashcode 方法。 因为别人知道源码怎么实现，故意构造相同的 hash 的字符串进行攻击，怎么处理？那 jdk7 怎么办？ 相同 hash 的字符串怎么进行攻击? 当客户端提交一个请求并附带参数的时候，web应用服务器会把我们的参数转化成一个 HashMap 存储，这个 HashMap 的逻辑结构如下：key1–&gt;value1; 但是物理存储结构是不同的，key 值会被转化成 Hashcode，这个 Hashcode 有会被转成数组的下标：0–&gt;value1； 不同的 String 就会产生相同 Hashcode 而导致碰撞，碰撞后的物理存储结构可能如下：0–&gt;value1–&gt;value2; 怎么处理构造相同的 hash 的字符串进行攻击： 限制POST和GET请求的参数个数，越少越好 限制POST请求的请求体大小 Web Application FireWall（WAF） JDK7如何处理： HashMap会动态的使用一个专门TreeMap实现来替换掉它。 字符串”+”号拼接平时开发过程中经常会使用”+”号拼接字符串，那么它的实现原理是怎么样的呢？我们通过java反编译看看是如何实现的，下载一个反编译工具cfr_0_132 String +号拼接常用列子 123456private static void demo1() &#123; int intd = 123; String stre = &quot;456&quot;; String f = intd + stre; System.out.println(f);&#125; 通过反编译工具cfr，将上面代码进行反编译后我们看看javac是怎么处理+的，执行反编译命令 123456private static void demo1() &#123; int intd = 123; String stre = &quot;456&quot;; String f = new StringBuilder().append(intd).append(stre).toString();//intd + stre; System.out.println(f);&#125; 与源代码对比一目了然： 1、+ 号使用 StringBuilder 替换了 2、变量 f 将 123+&quot;456&quot; 编译成 &quot;123456&quot;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://www.xiaojianblog.top/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.xiaojianblog.top/tags/java/"}]},{"title":"Java基础-2面向对象","slug":"Java基础-2面向对象","date":"2019-07-27T09:30:52.000Z","updated":"2019-08-25T16:12:03.000Z","comments":true,"path":"2019/07/27/Java基础-2面向对象/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/27/Java%E5%9F%BA%E7%A1%80-2%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"面向对象的特征 封装 继承 多态 java的四个基本特性：抽象、继承、封装、多态","text":"面向对象的特征 封装 继承 多态 java的四个基本特性：抽象、继承、封装、多态 封装​ 封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。 继承​ 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。 关于继承如下 3 点请记住： 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。（以后介绍）。 继承的好处和坏处 好处： 类不能改变父类的接口 创建子类的对象时，无须创建父类的对象 坏处: 破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性 支持扩展，但是往往以增加系统结构的复杂度为代价 不支持动态继承。在运行时，子类无法选择不同的父类 子类不能改变父类的接口 访问权限public、 private、 default、 protected 访问级别 范文控制修饰符 同类 同包 子类 不同包 公开 public √ √ √ √ 受保护 protected √ √ √ – 默认 没有访问控制修饰符 √ √ – – 私有 private √ – – – 多态​ 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 ​ 在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。 面向对象和面向过程的区别 面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。 面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。 重写与重载1. 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 不能存在同一个类中，在继承或实现关系的类中； 名相同，参数列表相同，方法返回值相同， 子类方法的访问修饰符要大于父类的。 子类的检查异常类型要小于父类的检查异常。 2. 重载（Overload） 可以在一个类中也可以在继承关系的类中； 名相同； 参数列表不同（个数，顺序，类型 至少有一个不同） 和方法的返回值类型无关。 抽象类和接口有什么区别抽象类 抽象类可以没有抽象方法,但是有抽象方法的类一定是抽象类 一个类只能继承一个类,也就是只能继承一个抽象类 抽象类内部,可以有抽象方法,也可以没有抽象方法,如果是抽象方法,那么如果子类不是抽象类,那么必须实现抽象方法 抽象类不可以被直接实例化,它只是对一个事物的抽象,只能被声明,不能被实例化 抽象类内 属性跟方法默认的访问权限都是 protected 抽象类内部可以定义 private 的属性跟方法 定义抽象类是使用在类名前加入 abstract 接口 接口是一系列方法的申明,JDK1.8之前接口内只有方法声明,没有方法的实现,JDK1.8后,接口可以定义默认的实现 接口只负责定义方法,具体的实现,将有子类去实现 接口所有方法,默认的访问权限都是 public 接口不能被直接实例化,因为它也是对一个事物的抽象,只能申明,不能被实例化 一个类可以实现多个接口 接口内部不能定义 private 的方法,因为私有方法没有实现是没有意义的 定义接口是使用 interface 面向对象开发的六个基本原则 单一职责：一个类只做它该做的事情(高内聚)。在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。 开放封闭：软件实体应当对扩展开放，对修改关闭。要做到开闭有两个要点： 抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点； 封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱。 里氏替换：任何时候都可以用子类型替换掉父类型。子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。 依赖倒置：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代） 合成聚和复用：优先使用聚合或合成关系复用代码。 接口隔离：接口要小而专，绝不能大而全。臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。","categories":[{"name":"java基础","slug":"java基础","permalink":"https://www.xiaojianblog.top/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.xiaojianblog.top/tags/java/"}]},{"title":"Java基础-1数据类型","slug":"Java基础-1数据类型","date":"2019-07-27T09:28:52.000Z","updated":"2019-08-08T10:45:53.000Z","comments":true,"path":"2019/07/27/Java基础-1数据类型/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/27/Java%E5%9F%BA%E7%A1%80-1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"数据类型八大基本数据类型：boolean、byte、char、short、int、long、float、double","text":"数据类型八大基本数据类型：boolean、byte、char、short、int、long、float、double 基本类型 数据类型 关键字 在内存中占用的字节数 取值范围 默认值 布尔型 boolean 1 true,false false 字节型 byte 1 -128 ~ 127 0 短整型 short 2 -2^15 ~ 2^15-1 0 整型 int 4 -2^31 ~ 2^31-1 0 长整型 long 8 -2^63 ~ 2^63-1 0 字符型 char 2 0 ~ 2^16-1 ‘\\u0000’ 单精度浮点型 float 4 1.4013E-45 ~ 3.4028E+38 0.0F 双精度浮点型 double 8 4.9E-324 ~ 1.7977E+308 0.0D short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 +=1;有什么错? 对于short s1=1;s1=s1+1来说，在s1+1运算时会自动提升表达式的类型为int，那么将int赋予给short类型的变量s1会出现类型转换错误。 对于short s1=1;s1+=1来说 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。 Integer和int的区别1、Integer是int的包装类，int则是java的一种基本数据类型 2、Integer变量必须实例化后才能使用，而int变量不需要 3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 4、Integer的默认值是null，int的默认值是0延伸： 关于Integer和int的比较 1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。 123Integer i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false 2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较） 123Integer i = new Integer(100);int j = 100；System.out.print(i == j); //true 3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同） 123Integer i = new Integer(100);Integer j = 100;System.out.print(i == j); //false 4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false 123Integer i = 100;Integer j = 100;System.out.print(i == j); //true 123Integer i = 128;Integer j = 128;System.out.print(i == j); //false 对于第4条的原因： java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下： 1234567public static Integer valueOf(int i)&#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123; return IntegerCache.cache[i + (-IntegerCache.low)]; &#125; return new Integer(i);&#125; ​ java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了 char类型变量能不能储存一个中文的汉字，为什么？​ char类型变量是用来储存Unicode编码的字符的，unicode字符集包含了汉字，所以char类型当然可以存储汉字的。 ​ 如果某个生僻字没有包含在unicode编码字符集中，那么char就不能存储该生僻字。 基本类型与引用类型的区别​ 基本类型保存原始值，引用类型保存的是引用值（引用值就是指对象在堆中所处的位置/地址）","categories":[{"name":"java基础","slug":"java基础","permalink":"https://www.xiaojianblog.top/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.xiaojianblog.top/tags/java/"}]},{"title":"AbstractQueuedSynchronizer源码剖析(一)从抽象和接口说起","slug":"AbstractQueuedSynchronizer源码剖析-一-从抽象和接口说起","date":"2019-07-27T08:33:11.000Z","updated":"2019-08-14T08:35:15.000Z","comments":true,"path":"2019/07/27/AbstractQueuedSynchronizer源码剖析-一-从抽象和接口说起/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/27/AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E4%B8%80-%E4%BB%8E%E6%8A%BD%E8%B1%A1%E5%92%8C%E6%8E%A5%E5%8F%A3%E8%AF%B4%E8%B5%B7/","excerpt":"从设计思想开始​ DK1.5 之后引入了并发 java.util.concurrent，大大提高了Java程序的并发性能。在介绍 Lock 之前，我们需要先熟悉一个非常重要的组件，掌握了该组件JUC包下面很多问题都不在是问题了。AQS 是构建锁或者其他同步组件的基础框架，JUC并发包的作者期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。","text":"从设计思想开始​ DK1.5 之后引入了并发 java.util.concurrent，大大提高了Java程序的并发性能。在介绍 Lock 之前，我们需要先熟悉一个非常重要的组件，掌握了该组件JUC包下面很多问题都不在是问题了。AQS 是构建锁或者其他同步组件的基础框架，JUC并发包的作者期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。 ​ AQS 从设计之初(即仅单单的从AQS本身来说)，它仅仅只是提供 独占锁和共享锁 两种方式，在这里请大家牢记，从AQS本身来说，是 不存在 所谓的 公平与非公平 性。AQS基于 模板模式 设计，因为从API的设计之初，作者（Doug Lea）已经预订了 任何一个子类只能支持AQS当中的 独占锁 和 共享锁 当中的一种 。所以AQS没有抽象方法，所有方法都有默认实现，这有区别于传统的 模板模式 。作者这样做的目的是让子类更加清洁，不需要实现无关的抽象方法。AQS继承自AOS。 123public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable ​ AOS里面只有一个属性，那就是 exclusiveOwnerThread ，也就是用来标识当前占有锁的线程。另外还有2个方法，分别用来 get 和 set 这个 exclusiveOwnerThread 。作者为什么需要将持有锁的线程的标识向上抽取？这是值得我们思考的。在JDK的源码中有对AQS这样的一段描述： ​ A synchronizer that may be exclusively owned by a thread. This class provides a basis for creating locks and related synchronizers that may entail a notion of ownership. The AbstractOwnableSynchronizer class itself does not manage or use this information. However, subclasses and tools may use appropriately maintained values to help control and monitor access and provide diagnostics. ​ 简单翻译如下：同步器是需要被线程互斥访问的。AOS提供了一个基本的概念，那就是创建锁时赋予一个对于这个锁的所有权。AOS本身并不会去管理或者去使用这些信息。然而子类或者其他工具类或许会在适当的时候去维护这些信息用来控制和监听访问控制权。AOS源码如下，为了阅读方便，我去掉了源码中的注释，但是我强烈建议你一定要记得去阅读它，这样你才能从框架的设计者口中得到最准确的关于这个类或者接口的设计说明。 12345678910111213141516public abstract class AbstractOwnableSynchronizer implements java.io.Serializable &#123; private static final long serialVersionUID = 3737899427754241961L; protected AbstractOwnableSynchronizer() &#123; &#125; private transient Thread exclusiveOwnerThread; protected final void setExclusiveOwnerThread(Thread thread) &#123; exclusiveOwnerThread = thread; &#125; protected final Thread getExclusiveOwnerThread() &#123; return exclusiveOwnerThread; &#125;&#125; ​ 到了这里，我们需要回答一个问题，那就是作者为什么需要将持有锁的线程的标识向上抽取？其实原因是很简单的。AQS诞生与JDK1.5，而AOS是在JDK1.6才出现的。也就是说在整个AQS的生命过程中，都没有用到AOS中声明的属性或方法，这些属性或方法是在AQS的子类中才用到的。也就是说，在JDK1.6以后，Doug Lea对AQS的子类实现做出了增强。那么Doug Lea为什么不直接把AOS中声明的属性或方法直接放在AQS中？或许Doug Lea认为如果这样做，是对AQS的一种侵入，因为AQS根本不需要这些，所以就往上抽取了一层。 AbstractQueuedSynchronizer暴露的API​ 在本文中，我不想谈到太多的关于AQS的实现细节，这些是接下来的博客将要阐述的内容。本文的宗旨是从思想、设计、实现思路等方面对AQS的介绍。我们知道，AQS仅仅只是提供 独占锁 和 共享锁 两种方式，但是每种方式都有 响应中断 和 不响应中断 的区别，所以说AQS锁的更细粒度的划分为： 不响应中断的独占锁(acquire) 响应中断的独占锁(acquireInterruptibly) 不响应中断的共享锁(acquireShared) 响应中断的共享锁(acquireSharedInterruptibly) ​ 这四种方式在AQS中的入口在上面已经标注，而释放锁的方式只有两种，独占锁的释放与共享锁的释放。分别为： 独占锁的释放(release) 共享锁的释放(releaseShared) ​ 因为AQS是基于模板模式的设计，可想而知，上面的方法，子类不应该去覆盖，因为这些方法定义了整体流程，事实上作者也阻止你去覆盖它，因为这些方法都是 final 的。在上面所有的方法中，都调用了与之相对应的 try 方法。在这里需要注意的一点是，acquire 和 acquireInterruptibly 在AQS中调用的是同一个 try 方法，acquireShared 和 acquireSharedInterruptibly 也是调用相同的 try 方法，并且 try 方法在AQS中都提供了空实现。也就是说，作者暗示着子类应该去重写这些try方法，至于如何去重写try方法，完全是子类的自由。 ​ 例如: ReentrantLock 是一个典型的独占锁，它提供了对 try 方法的实现，并且提供了两种实现方式。这两种不同的 try 方式，就衍生出了 公平与非公平 的概念。即 ReentrantLock 提供如下： 非公平方式的不响应中断的独占锁 非公平方式的响应中断的独占锁 公平方式的不响应中断的独占锁 公平方式的响应中断的独占锁 这里我们只是简单的阐述，关于ReentrantLock，在之后我会专门讲解。本文介绍AQS已经结束。 如何更加合理的解释acquire这个动词​ 在AQS中，有很多API的名字很难让人读懂。按照 Java 的命名规范，方法的名称应该是动词+名词，例如getUser ，我们就很容易的知道这个API是获取用户信息的。而在AQS中，可没有那么简单。首先这篇文章是为了后续文章做铺垫的，所以你应该需要去读懂并尽量理解这些思想。 ​ 所谓“锁”，在AQS中，其实质是让线程获取AQS中的 state 的状态值，一旦可以成功获取到状态值（读到值，并且将原值加1成功），那么该线程就有运行临界区代码的权限。如何去 acquire ？以什么方式去 acquire ？当前线程目前在哪里(换句话说，当前线程是在 CLH 队列之中，还是目前没有入 CLH 队列)？所以一个完整的方法命名与解读应该遵循如下规则： ​ 独占锁的方法命名与解读： acquire*+[在哪里]+[state] 比如: ​ acquire方法理解：当前线程以不响应中断的方式，在 CLH 队列外，请求AQS的 state。 ​ acquireInterruptibly方法理解：当前线程以响应中断的方式，在 CLH 队列外，请求AQS的 state。 ​ acquireQueued方法理解：当前线程以不响应中断的方式，在 CLH 队列里，请求AQS的 state。","categories":[{"name":"AQS","slug":"AQS","permalink":"https://www.xiaojianblog.top/categories/AQS/"}],"tags":[{"name":"AQS源码","slug":"AQS源码","permalink":"https://www.xiaojianblog.top/tags/AQS%E6%BA%90%E7%A0%81/"}]},{"title":"Netty源码分析(三)Netty服务端ServerBootstrap的初始化与反射在其中的应用分析","slug":"Netty源码分析-三-Netty服务端ServerBootstrap的初始化与反射在其中的应用分析","date":"2019-07-26T09:28:52.000Z","updated":"2019-08-01T08:59:38.000Z","comments":true,"path":"2019/07/26/Netty源码分析-三-Netty服务端ServerBootstrap的初始化与反射在其中的应用分析/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/26/Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%89-Netty%E6%9C%8D%E5%8A%A1%E7%AB%AFServerBootstrap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%B0%84%E5%9C%A8%E5%85%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90/","excerpt":"前言​ 上一节说到 EventLoopGroup 只是对 bossGroup 和 workerGroup 的一些初始化，包括线程数量，执行器（命令模式），我们的服务端接下来使用 ServerBootstrap 对 bossGroup 和 workerGroup 进行了包装，整个过程是一个方法链的调用过程，每个方法返回调用者本身。","text":"前言​ 上一节说到 EventLoopGroup 只是对 bossGroup 和 workerGroup 的一些初始化，包括线程数量，执行器（命令模式），我们的服务端接下来使用 ServerBootstrap 对 bossGroup 和 workerGroup 进行了包装，整个过程是一个方法链的调用过程，每个方法返回调用者本身。 123456789101112131415161718192021222324252627public class MyServer &#123; public static void main(String[] args) &#123; //将用户请求转发给workGroup EventLoopGroup bossGroup = new NioEventLoopGroup(1); //完成用户请求 EventLoopGroup workGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); // 方法链的调用过程，返回值都是 return this; 调用者本身 serverBootstrap.group(bossGroup, workGroup).channel(NioServerSocketChannel.class). childHandler(new MyServerInitializer()); ChannelFuture channelFuture = serverBootstrap.bind(8899).sync(); channelFuture.channel().closeFuture().sync(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; bossGroup.shutdownGracefully(); workGroup.shutdownGracefully(); &#125; &#125;&#125; 然后进行了启动，先看一下ServerBootstrap的结构： 12345678910111213141516171819202122232425262728 //&#123;@link Bootstrap&#125; sub-class which allows easy bootstrap of &#123;@link ServerChannel&#125; //Bootstrap的子类型，用来启动ServerChannel，父类是AbstractBootstrap，父类的泛型是它的子类类型ServerBootstrap和 //要启动的ServerChannel类型。public class ServerBootstrap extends AbstractBootstrap&lt;ServerBootstrap, ServerChannel&gt; &#123; ...略 private volatile EventLoopGroup childGroup;//即之前创建的workerGroup，实际处理数据的EventLoopGroup。 ...略 public ServerBootstrap() &#123; &#125; //构造器非常简化。 ...略 /** * Set the &#123;@link EventLoopGroup&#125; for the parent (acceptor) and the child (client). These * &#123;@link EventLoopGroup&#125;&#x27;s are used to handle all the events and IO for &#123;@link ServerChannel&#125; and * &#123;@link Channel&#125;&#x27;s. * parentGroup放在父类AbstractBootstrap里边，即acceptor，childGroup放在当前类里边，即client * EventLoopGroup的作用就是处理所有的ServerChannel和Channel的io事件。 */ public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) &#123; super.group(parentGroup);//调父类的构造器，将parentGroup放在父类 if (childGroup == null) &#123; throw new NullPointerException(&quot;childGroup&quot;); &#125; if (this.childGroup != null) &#123; throw new IllegalStateException(&quot;childGroup set already&quot;); &#125; this.childGroup = childGroup;//childGroup放在子类里边 return this; &#125; 我们切换到父类AbstractBootstrap： 123456789101112131415161718192021//泛型B是AbstractBootstrap的子类类型，当前是ServerBootstrap，C是通道类型，当前是NioServerSocketChannel（后续会提到）public abstract class AbstractBootstrap&lt;B extends AbstractBootstrap&lt;B, C&gt;, C extends Channel&gt; implements Cloneable &#123; ...略 private volatile ChannelFactory&lt;? extends C&gt; channelFactory;//Channel类型的C会被反射成实体，放在ChannelFactory //里边，后边会说。 /** * The &#123;@link EventLoopGroup&#125; which is used to handle all the events for the to-be-created * &#123;@link Channel&#125; */ @SuppressWarnings(&quot;unchecked&quot;) public B group(EventLoopGroup group) &#123; if (group == null) &#123; throw new NullPointerException(&quot;group&quot;); &#125; if (this.group != null) &#123; throw new IllegalStateException(&quot;group set already&quot;); &#125; this.group = group; return (B) this;//返回子类型ServerBootstrap。 &#125; ...略 接下来会调用serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class)，channel方法，channel位于父类AbstractBootstrap里边： 12345678910111213/** * The &#123;@link Class&#125; which is used to create &#123;@link Channel&#125; instances from. * You either use this or &#123;@link #channelFactory(io.netty.channel.ChannelFactory)&#125; if your * &#123;@link Channel&#125; implementation has no no-args constructor. * channelClass即我们的参数NioServerSocketChannel.class，new ReflectiveChannelFactory&lt;C&gt;(channelClass)使用反射生成了 * NioServerSocketChannel的实例（无参构造器）， */public B channel(Class&lt;? extends C&gt; channelClass) &#123; if (channelClass == null) &#123; throw new NullPointerException(&quot;channelClass&quot;); &#125; return channelFactory(new ReflectiveChannelFactory&lt;C&gt;(channelClass));&#125; 这里用到了ReflectiveChannelFactory，这里牵扯了三个factory和他们之间的关系，如图： 这个图我们只要了解一下即可，接下来 return channelFactory(new ReflectiveChannelFactory(channelClass));，进入channelFactory方法： 1234//入参：channelFactory类型io.netty.channel.ChannelFactory public B channelFactory(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory) &#123; return channelFactory((ChannelFactory&lt;C&gt;) channelFactory); &#125; 继续走： 123456789101112131415//入参：channelFactory类型io.netty.bootstrap.ChannelFactory public B channelFactory(ChannelFactory&lt;? extends C&gt; channelFactory) &#123; if (channelFactory == null) &#123; throw new NullPointerException(&quot;channelFactory&quot;); &#125; if (this.channelFactory != null) &#123; throw new IllegalStateException(&quot;channelFactory set already&quot;); &#125; this.channelFactory = channelFactory; //即AbstractBootstrap的成员变量channelFactory被赋值，实际上是一个ReflectiveChannelFactory。 //private volatile ChannelFactory&lt;? extends C&gt; channelFactory; return (B) this;//返回子类型ServerBootstrap 为了链式方法调用 &#125; 接下是serverBootstrap.group( bossGroup, workerGroup ).channel( NioServerSocketChannel.class ).childHandler( new MyServerInitializer() ); childHandler方法： 1234567891011/** * Set the &#123;@link ChannelHandler&#125; which is used to serve the request for the &#123;@link Channel&#125;&#x27;s. * childHandler是为了服务客户端的request请求。 */public ServerBootstrap childHandler(ChannelHandler childHandler) &#123; if (childHandler == null) &#123; throw new NullPointerException(&quot;childHandler&quot;); &#125; this.childHandler = childHandler;//只是简单的赋值 return this;&#125; 到目前为止：bossGroup 位于父类AbstractBootstrap，workerGroup位于ServerBootstrap ，NioServerSocketChannel位于AbstractBootstrapChannelHandler位于ServerBootstrap ，这写操作都是数据的准备，为了后边的启动： 1ChannelFuture channelFuture = serverBootstrap.bind(8899).sync();11 bind方法： 1234567/** * Create a new &#123;@link Channel&#125; and bind it. * 创建一个新的channel绑定到ServerBootstrap 上 */public ChannelFuture bind(int inetPort) &#123; return bind(new InetSocketAddress(inetPort));&#125; 方法最终调用dobind：这个方法是启动服务的比较重要的一个实现 1234567891011121314151617181920212223242526272829303132333435private ChannelFuture doBind(final SocketAddress localAddress) &#123; final ChannelFuture regFuture = initAndRegister(); final Channel channel = regFuture.channel(); if (regFuture.cause() != null) &#123; return regFuture; &#125; if (regFuture.isDone()) &#123; // At this point we know that the registration was complete and successful. ChannelPromise promise = channel.newPromise(); doBind0(regFuture, channel, localAddress, promise); return promise; &#125; else &#123; // Registration future is almost always fulfilled already, but just in case it&#x27;s not. final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel); regFuture.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) throws Exception &#123; Throwable cause = future.cause(); if (cause != null) &#123; // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an // IllegalStateException once we try to access the EventLoop of the Channel. promise.setFailure(cause); &#125; else &#123; // Registration was successful, so set the correct executor to use. // See https://github.com/netty/netty/issues/2586 promise.registered(); doBind0(regFuture, channel, localAddress, promise); &#125; &#125; &#125;); return promise; &#125; &#125; 下一节我们从initAndRegister方法开始讲解。","categories":[{"name":"Netty","slug":"Netty","permalink":"https://www.xiaojianblog.top/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://www.xiaojianblog.top/tags/Netty/"}]},{"title":"kisso单点登录","slug":"项目-kisso单点登录详解","date":"2019-07-26T02:31:52.000Z","updated":"2019-08-08T10:42:59.000Z","comments":true,"path":"2019/07/26/项目-kisso单点登录详解/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/26/%E9%A1%B9%E7%9B%AE-kisso%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E8%AF%A6%E8%A7%A3/","excerpt":"介绍​ kisso 采用的是加密会话 cookie 机制实现单点登录 SSO 服务，具备“无状态”、“分散验证” 等特性。","text":"介绍​ kisso 采用的是加密会话 cookie 机制实现单点登录 SSO 服务，具备“无状态”、“分散验证” 等特性。 session 存放在服务器端，cookie 存放在客户端，存在 2 种状态：“ 第一种：持久 cookie 具有时效性，以文件的形式存放在客户机硬盘中， 时间一到生命周期结束自动被删除。第二种：临时 cookie 又叫会话 cookie 放在浏览器 内存中，浏览器关闭生命周期结束自动失效 ”。 单纯不做任何改变而言 session 更安全，如果 cookie 采取各种安全保护措施，此时的 cookie 一样安全。 cookie 轻松实现分布式服务部署，单点登录跨域访问等问题，换成 session 需要处理 session 复制及各种问题实现困难。 KiSSO实现统一身份认证服务验证流程 流程图 加Redis缓存具体代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.baomidou.kisso.springmvc.cache;import com.baomidou.kisso.SSOCache;import com.baomidou.kisso.security.token.SSOToken;import com.baomidou.kisso.springmvc.utils.RedisUtil;import org.springframework.beans.factory.annotation.Autowired;/** * @author 小贱 * @create 2019-07-07 15:46 */public class RedisCache implements SSOCache &#123; @Autowired RedisUtil redisUtil; @Override public SSOToken get(String s, int i) &#123; if(exists(s))&#123; String result = redisUtil.get(s); return SSOToken.parser(result, false); &#125; return null; &#125; @Override public boolean set(String s, SSOToken token, int i) &#123; boolean result = false; try &#123; delete(s); redisUtil.set(s, token.getToken(), i); result = true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; @Override public boolean delete(String s) &#123; boolean result = false; try&#123; if (exists(s)) &#123; redisUtil.delete(s); return true; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return result; &#125; public boolean exists(final String key) &#123; return redisUtil.get(key)!=null; &#125;&#125; 防 XSS 攻击 和 SQL 注入XSS简介跨站脚本（cross site script）简称为XSS，是一种经常出现在web应用中的计算机安全漏洞，也是web中最主流的攻击方式。 XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码。 XSS攻击的危害 1、盗取用户资料，比如：登录帐号、网银帐号等 2、利用用户身份，读取、篡改、添加、删除企业敏感数据等 3、盗窃企业重要的具有商业价值的资料 4、非法转账 5、强制发送电子邮件 6、网站挂马 7、控制受害者机器向其它网站发起攻击 防止XSS解决方案​ XSS的根源主要是没完全过滤客户端提交的数据 ，所以重点是要过滤用户提交的信息。将重要的 cookie 标记为 http only , 这样的话 js 中的 document.cookie 语句就不能获取到 cookie 了. ​ 只允许用户输入我们期望的数据。 例如：age用户年龄只允许用户输入数字，而数字之外的字符都过滤掉。对数据进行Html Encode 处理： 用户将数据提交上来的时候进行HTML编码，将相应的符号转换为实体名称再进行下一步的处理。 1. 过滤或移除特殊的Html标签， 例如: &lt;script&gt;, &lt;iframe&gt; , &lt; for &lt;, &gt; for &gt;, &amp;quot for 过滤js事件的标签。例如 “οnclick=”, “onfocus” 等等。 SQL注入简介​ SQL注入是比较常见的网络攻击方式之一，主要是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，实现无帐号登录，甚至篡改数据库。 SQL注入的危害 1.数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。 2. 网页篡改：通过操作数据库对特定网页进行篡改。 3. 数据库被恶意操作：数据库服务器被攻击 4. 服务器被远程控制，被安装后门 5. 删除和修改数据库信息 防止SQL注入的方式 通常情况下，SQL注入的位置包括： （1）表单提交，主要是POST请求，也包括GET请求； （2）URL参数提交，主要为GET请求参数； （3）Cookie参数提交； （4）HTTP请求头部的一些可修改的值，比如Referer、User_Agent等； 防止SQL注入的解决方案 （1）对用户的输入进行校验，使用正则表达式过滤传入的参数 （2）使用参数化语句，不要拼接sql，也可以使用安全的存储过程 （3）不要使用管理员权限的数据库连接，为每个应用使用权限有限的数据库连接 （4）检查数据存储类型 （5）重要的信息一定要加密 RSA 非对称加密RSA加密简介 RSA加密是一种非对称加密。可以在不直接传递密钥的情况下，完成解密。这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。是由一对密钥来进行加解密的过程，分别称为公钥和私钥。两者之间有数学相关，该加密算法的原理就是对一极大整数做因数分解的困难性来保证安全性。通常个人保存私钥，公钥是公开的（可能同时多人持有）。 RSA加密、签名区别 加密和签名都是为了安全性考虑，但略有不同。常有人问加密和签名是用私钥还是公钥？其实都是对加密和签名的作用有所混淆。简单的说，加密是为了防止信息被泄露，而签名是为了防止信息被篡改。这里举2个例子说明。 第一个场景：战场上，B要给A传递一条消息，内容为某一指令。 RSA的加密过程如下： （1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。 （2）A传递自己的公钥给B，B用A的公钥对消息进行加密。 （3）A接收到B加密的消息，利用A自己的私钥对消息进行解密。 在这个过程中，只有2次传递过程，第一次是A传递公钥给B，第二次是B传递加密消息给A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。 第二个场景：A收到B发的消息后，需要进行回复“收到”。 RSA签名的过程如下： （1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。 （2）A用自己的私钥对消息加签，形成签名，并将加签的消息和消息本身一起传递给B。 （3）B收到消息后，在获取A的公钥进行验签，如果验签出来的内容与消息本身一致，证明消息是A回复的。 在这个过程中，只有2次传递过程，第一次是A传递加签的消息和消息本身给B，第二次是B获取A的公钥，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行签名，即使知道了消息内容，也无法伪造带签名的回复给B，防止了消息内容的篡改。 但是，综合两个场景你会发现，第一个场景虽然被截获的消息没有泄露，但是可以利用截获的公钥，将假指令进行加密，然后传递给A。第二个场景虽然截获的消息不能被篡改，但是消息的内容可以利用公钥验签来获得，并不能防止泄露。所以在实际应用中，要根据情况使用，也可以同时使用加密和签名，比如A和B都有一套自己的公钥和私钥，当A要给B发送消息时，先用B的公钥对消息加密，再对加密的消息使用A的私钥加签名，达到既不泄露也不被篡改，更能保证消息的安全性。 总结：公钥加密、私钥解密、私钥签名、公钥验签。","categories":[{"name":"项目","slug":"项目","permalink":"https://www.xiaojianblog.top/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://www.xiaojianblog.top/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"kisso","slug":"kisso","permalink":"https://www.xiaojianblog.top/tags/kisso/"},{"name":"单点登录","slug":"单点登录","permalink":"https://www.xiaojianblog.top/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"}]},{"title":"秒杀、抢购项目详解","slug":"项目-秒杀、抢购详解","date":"2019-07-25T02:31:52.000Z","updated":"2019-08-08T14:22:16.000Z","comments":true,"path":"2019/07/25/项目-秒杀、抢购详解/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/25/%E9%A1%B9%E7%9B%AE-%E7%A7%92%E6%9D%80%E3%80%81%E6%8A%A2%E8%B4%AD%E8%AF%A6%E8%A7%A3/","excerpt":"前言​ 所谓“秒杀”，就是网络卖家发布一些超低价格的商品，所有买家在同一时间网上抢购的一种销售方式。通俗一点讲就是网络商家为促销等目的组织的网上限时抢购活动。由于商品价格低廉，往往一上架就被抢购一空，有时只用一秒钟。","text":"前言​ 所谓“秒杀”，就是网络卖家发布一些超低价格的商品，所有买家在同一时间网上抢购的一种销售方式。通俗一点讲就是网络商家为促销等目的组织的网上限时抢购活动。由于商品价格低廉，往往一上架就被抢购一空，有时只用一秒钟。 项目设计要点 项目流程总的流程图 数据库设计goods order 项目流程详解定时任务通过 Spring 的 @Scheduled 注解实现定时任务 GoodsRedisStoreInitTask 商品redis库存初始化任务123456789101112131415161718/** * 每隔1分钟触发一次 */@Scheduled(cron = &quot;0 0/1 * * * ? &quot;)public void doInit() &#123; List&lt;Goods&gt; goods = goodsMapper.selectAll(); for (Goods item : goods) &#123; goodsRedisStore.doInit(item); &#125;&#125;// goodsRedisStore.doInit(item)public void doInit(Goods goods) &#123; String key = getKey(goods.getRandomName()); // 如果没有初始化库存则初始化 if (!redisUtil.exists(key)) &#123; redisUtil.set(key, goods.getStore() * 1); &#125;&#125; 以 REDIS_GOODS_STORE_GOODS_RANDOM_NAME:+商品唯一标识符 为 key；商品库存 store 为 value。 GoodsTokenExpireClearTask 商品token过期清理任务每当用户抢购成功都会生成 token ，而用户没有在规定的时间内下单支付就会过期，如果token存在，且是过期的，则 redis 库存 +1 1234567891011/** * 每隔1分钟触发一次 */@Scheduled(cron = &quot;0 0/1 * * * ? &quot;)public void doClear() &#123; Set&lt;String&gt; keys = miaoshaSuccessTokenCache.getAllToken(); for(String key : keys)&#123; //验证token是否过期，过期了自动释放redis库存 miaoshaSuccessTokenCache.validateTokenByKey(key); &#125;&#125; 以 MIAOSHA_SUCCESS_TOKEN_MOBILE:+手机号+_GOODS_RANDOM_NAME:+商品唯一标识符+_token 为 key；抢购成功时间 为 value。 前端获取商品列表和商品详情页就不介绍了，我们来说说商品抢购按钮URL的地址拼接 在前端页面中，会先判断用户是否登录，没有登录则会弹出登录窗口，然后获取系统当前时间，最后与商品的开始时间与结束时间进行比较，判断当前商品的状态：1秒杀结束、2倒计时、3开始秒杀 当秒杀开始时，通过ajax获取商品唯一标识 randomName 并显示秒杀按钮，点击秒杀按钮 会将 randomName 和 手机号 发送到后端，请求成功后开启定时查询抢购结果的方法。至此，秒杀的核心功能开始了 注：代码太多就不贴了，具体代码在 webapp\\resource\\script\\seckill.js 中 秒杀恶意用户及IP拦截UserInterceptor 恶意用户拦截具体功能是： 判断用户手机号是否在Redis用户黑名单缓存中， 判断用户请求+1后是否达到黑名单要求，即1秒内访问次数超过10次 都不符合则增加缓存，以 key：user_request_time_prefix + 手机号 ；value 为 访问时间 的list 类型。 IPInterceptor 恶意IP拦截具体功能是： 获取用户的真实IP，并判断IP是否正常 判断IP是否在Redis的IP黑名单中 判断请求+1后是否达到黑名单要求，即1秒内访问次数超过10次 都不符合则增加缓存，以 key：ip_request_time_prefix + IP号 ；value 为 访问时间 的list 类型。 MiaoshaInterface.miaosha()秒杀方法部分流程图详解 这里面用到很多的Redis Redis key value 秒杀商品是否结束 MIAOSHA_FINISH…+randomName null或者非null，null则未结束 消息对列 MIAOSHA_MESSAGE Message 处理列表 MIAOSHA_HANDLE_LIST+randomName 手机号 削锋秒杀活动是希望更多的人来参与，也就是抢购之前希望有越来越多的人来看购买商品。 但是，在抢购时间达到后，用户开始真正下单时，秒杀的服务器后端缺不希望同时有几百万人同时发起抢购请求。 我们都知道服务器的处理资源是有限的，所以出现峰值的时候，很容易导致服务器宕机，用户无法访问的情况出现。 削峰从本质上来说就是更多地延缓用户请求，以及层层过滤用户的访问需求，遵从“最后落地到数据库的请求数要尽量少”的原则。 要对流量进行削峰，最容易想到的解决方案就是用消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。 消息对列（异步）AbstarctMessageHandler 消息监听器 实现 Runnable 接口 1public abstract class AbstarctMessageHandler&lt;T&gt; implements Runnable 123456789/** * 初始化启动本监听器 */@PostConstructpublic void startListen()&#123; // 启动监听 new Thread(this).start();&#125; run() 方法具体功能是 循环 listen() 方法 1234567public void run()&#123; while (true) &#123; listen(); &#125;&#125; listen() 方法 阻塞的获取 Redis 中消息对列的值 key 为 MIAOSHA_MESSAGE，如果消息对列中没有值，则一直阻塞 提交任务到线程池 ThreadPoolTaskExecutor ，核心功能交给子类 MiaoshaRequestHandler 的 handle 方法处理，如果处理失败，则判断失败次数，满足重试资格次数+1，并重新put到消息对列中。 MiaoshaRequestHandler.handle(message) 判断用户是否在黑名单中 判断抢购是否结束 减 Redis 的库存 decr() 方法 根据 手机号 和 商品randomName 生成 token ，并将token添加到Redis中。 注：这里的减库存操作不会影响到DB数据库 下订单在上面的前端中说到 “请求成功后开启定时查询抢购结果的方法” ，该方法是通过Redis查询该手机号和商品randomName的token是否存在，存在则提供下单接口，执行下单功能 具体流程图","categories":[{"name":"项目","slug":"项目","permalink":"https://www.xiaojianblog.top/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://www.xiaojianblog.top/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"秒杀","slug":"秒杀","permalink":"https://www.xiaojianblog.top/tags/%E7%A7%92%E6%9D%80/"}]},{"title":"Netty源码分析(二)Netty对Executor的实现机制源码分析","slug":"Netty源码分析-二-Netty对Executor的实现机制源码分析","date":"2019-07-17T08:33:11.000Z","updated":"2019-08-01T01:57:30.000Z","comments":true,"path":"2019/07/17/Netty源码分析-二-Netty对Executor的实现机制源码分析/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/17/Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C-Netty%E5%AF%B9Executor%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"前言​ 上一次我们说到 NioEventLoopGroup 的初始化，其中父类 MultithreadEventExecutorGroup 的构造器中包含 Executor 的创建，这次我们来看看 Executor 的实现机制。","text":"前言​ 上一次我们说到 NioEventLoopGroup 的初始化，其中父类 MultithreadEventExecutorGroup 的构造器中包含 Executor 的创建，这次我们来看看 Executor 的实现机制。 起源​ Executor 是在 MultithreadEventExecutorGroup 的构造器中创建的，具体代码如下 1234567891011protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args) &#123; if (nThreads &lt;= 0) &#123; throw new IllegalArgumentException(String.format(&quot;nThreads: %d (expected: &gt; 0)&quot;, nThreads)); &#125; if (executor == null) &#123; executor = new ThreadPerTaskExecutor(newDefaultThreadFactory()); &#125; ... ...&#125; newDefaultThreadFactory 方法​ MultithreadEventExecutorGroup.newDefaultThreadFactory() 具体代码如下： 123protected ThreadFactory newDefaultThreadFactory() &#123; return new DefaultThreadFactory(getClass());&#125; ​ DefaultThreadFactory默认线程工厂类，继承了ThreadFactory public class DefaultThreadFactory implements ThreadFactory ​ 其下的构造方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 参数 poolType 为 newDefaultThreadFactory 的 class， * false表示线程不是后台线程， * Thread.NORM_PRIORITY，是正常的线程的优先级， * (三个优先级：MIN_PRIORITY = 1;NORM_PRIORITY = 5;MAX_PRIORITY = 10;)。 */public DefaultThreadFactory(Class&lt;?&gt; poolType) &#123; this(poolType, false, Thread.NORM_PRIORITY);&#125;/** * toPoolName(poolType)的功能是：将类的包名去掉，并将其首字母改为小写的简单命名规则 * 比如我们给定当前newDefaultThreadFactory的poolType为 * io.netty.util.concurrent.newDefaultThreadFactory, * 那么经过toPoolName（）方法返回为newDefaultThreadFactory */public DefaultThreadFactory(Class&lt;?&gt; poolType, boolean daemon, int priority) &#123; this(toPoolName(poolType), daemon, priority);&#125;/** * 加入了线程组参数 */public DefaultThreadFactory(String poolName, boolean daemon, int priority) &#123; this(poolName, daemon, priority, System.getSecurityManager() == null ? Thread.currentThread().getThreadGroup() : System.getSecurityManager().getThreadGroup());&#125;public DefaultThreadFactory(String poolName, boolean daemon, int priority, ThreadGroup threadGroup) &#123; if (poolName == null) &#123; throw new NullPointerException(&quot;poolName&quot;); &#125; if (priority &lt; Thread.MIN_PRIORITY || priority &gt; Thread.MAX_PRIORITY) &#123; throw new IllegalArgumentException( &quot;priority: &quot; + priority + &quot; (expected: Thread.MIN_PRIORITY &lt;= priority &lt;= Thread.MAX_PRIORITY)&quot;); &#125; /** * poolId:private static final AtomicInteger poolId = new AtomicInteger(); * 原子性操作，incrementAndGet()作用是‘+1’； * 在多线程中保证线程安全。 */ prefix = poolName + &#x27;-&#x27; + poolId.incrementAndGet() + &#x27;-&#x27;; this.daemon = daemon; //是否后台线程 this.priority = priority; //优先级 this.threadGroup = threadGroup; //线程组&#125; ​ 讲完了构造方法，到现在只是指定了线程的一些属性的设置，我们再返回去看 MultithreadEventExecutorGroup 的 newDefaultThreadFactory 方法，newDefaultThreadFactory 返回的是 ThreadFactory 类 protected ThreadFactory newDefaultThreadFactory() { return new DefaultThreadFactory(getClass());} 1234567/** * 将一个 Runnable 做成一个 Thread ，并且可以指定线程的name、daemon、status、ThreadGroup * 在1.8中，只包含一个抽象方法的接口叫函数式接口 */public interface ThreadFactory &#123; Thread newThread(Runnable r);&#125; ​ newThread(Runnable r) 的具体实现在下面会详细分析 ThreadPerTaskExecutor 方法​ 我们创建完DefaultThreadFactory之后将返回值 ThreadFactory 给了ThreadPerTaskExecutor executor = new ThreadPerTaskExecutor(newDefaultThreadFactory()); 12345678910111213141516171819202122232425262728293031/** * ThreadPerTaskExecutor 使用了命令模式，execute执行的是命令。 * ThreadPerTaskExecutor的构造方法只是把DefaultThreadFactory传递进来。 * 还运用了代理模式，本来应该 ThreadPerTaskExecutor 执行的命令，代理给了 ThreadFactory 去执行。 */public final class ThreadPerTaskExecutor implements Executor &#123; //定义一个私有的线程工厂 private final ThreadFactory threadFactory; //定义一个ThreadPerTaskExecutor构造方法 public ThreadPerTaskExecutor(ThreadFactory threadFactory) &#123; if (threadFactory == null) &#123; throw new NullPointerException(&quot;threadFactory&quot;); &#125; this.threadFactory = threadFactory; &#125; /** * 这个是一个命令模式 * 这个execute方法的作用是：在将来的某个时间执行给定的命令。 * 该命令可以在Executor实现的判断下在新线程，池化线程或调用线程中执行 */ @Override public void execute(Runnable command) &#123; /** * ThreadFactory 执行命令，其具体实现是在 DefaultThreadFactory 中 * 稍后我们到 DefaultThreadFactory 里边看看 newThread 方法 */ threadFactory.newThread(command).start(); &#125;&#125; DefaultThreadFactory.newThread() 方法 实现 ThreadFactory 接口的方法 1234567891011121314151617@Overridepublic Thread newThread(Runnable r) &#123; //将参数r包装为一个DefaultRunnableDecorator(实现了Runnable) Thread t = newThread(new DefaultRunnableDecorator(r), prefix + nextId.incrementAndGet()); try &#123; if (t.isDaemon() != daemon) &#123; t.setDaemon(daemon); &#125; if (t.getPriority() != priority) &#123; t.setPriority(priority); &#125; &#125; catch (Exception ignored) &#123; // Doesn&#x27;t matter even if failed to set. &#125; return t;&#125; 切到DefaultRunnableDecorator: //（DefaultRunnableDecorator）是 DefaultThreadFactory 的内部类 123456789101112131415161718192021222324public class DefaultThreadFactory implements ThreadFactory &#123; ...... private static final class DefaultRunnableDecorator implements Runnable &#123; private final Runnable r; DefaultRunnableDecorator(Runnable r) &#123; this.r = r; &#125; @Override public void run() &#123; try &#123; /** * 直接调用的命令的run方法，并没有创建线程 * 也就是说 threadFactory.newThread(command).start()只有一个线程。 */ r.run(); &#125; finally &#123; FastThreadLocal.removeAll(); &#125; &#125; &#125;&#125; ​ 这种调用方式和 jdk 内置的 Executor（ThreadPerTaskExecutor implements Executor）如出一撤, DefaultRunnableDecorator 的 run（通过 Thread 的 start 调用）直接调用了 Runnable 的 run 方法，我们去看一些Executor的文档： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/** * An object that executes submitted &#123;@link Runnable&#125; tasks. This * interface provides a way of decoupling task submission from the * mechanics of how each task will be run, including details of thread * use, scheduling, etc. An &#123;@code Executor&#125; is normally used * instead of explicitly creating threads. For example, rather than * invoking &#123;@code new Thread(new(RunnableTask())).start()&#125; for each * of a set of tasks, you might use: * 大体意思是将任务（线程）的提交和任务的执行解耦， * 例如new Thread(new(RunnableTask())).start()这种方式被得到替换。 * * &lt;pre&gt;使用方式 * Executor executor = &lt;em&gt;anExecutor&lt;/em&gt;; * executor.execute(new RunnableTask1()); * executor.execute(new RunnableTask2()); * ... * &lt;/pre&gt; * * However, the &#123;@code Executor&#125; interface does not strictly * require that execution be asynchronous. In the simplest case, an * executor can run the submitted task immediately in the caller&#x27;s * thread: * 当然Executor不会严格的要求执行是异步的，因为在有些情况会被调用线程直接执行任务的run方法。 * * &lt;pre&gt; &#123;@code * class DirectExecutor implements Executor &#123; * public void execute(Runnable r) &#123; * r.run(); //在当前线程（调动者线程）运行任务。 * &#125; * &#125;&#125;&lt;/pre&gt; * * More typically, tasks are executed in some thread other * than the caller&#x27;s thread. The executor below spawns a new thread * for each task. * 典型的方式是将任务依附在一个new Thread上执行，是一个新的线程。 * * &lt;pre&gt; &#123;@code * class ThreadPerTaskExecutor implements Executor &#123; * public void execute(Runnable r) &#123; * new Thread(r).start(); * &#125; * &#125;&#125;&lt;/pre&gt; * * Many &#123;@code Executor&#125; implementations impose some sort of * limitation on how and when tasks are scheduled. The executor below * serializes the submission of tasks to a second executor, * illustrating a composite executor. * 有的时候任务会被串行的被多个tasks 执行，A-&gt;B-&gt;C-&gt;D，是一个流水的过程。 * * &lt;pre&gt; &#123;@code * class SerialExecutor implements Executor &#123; * final Queue&lt;Runnable&gt; tasks = new ArrayDeque&lt;Runnable&gt;(); * final Executor executor; * Runnable active; * * SerialExecutor(Executor executor) &#123; * this.executor = executor; * &#125; * * public synchronized void execute(final Runnable r) &#123; * tasks.offer(new Runnable() &#123; * public void run() &#123; * try &#123; * r.run(); * &#125; finally &#123; * scheduleNext();//转到下一个task执行。 * &#125; * &#125; * &#125;); * if (active == null) &#123; * scheduleNext(); * &#125; * &#125; * * protected synchronized void scheduleNext() &#123; * if ((active = tasks.poll()) != null) &#123; * executor.execute(active); * &#125; * &#125; * &#125;&#125;&lt;/pre&gt; * * The &#123;@code Executor&#125; implementations provided in this package * implement &#123;@link ExecutorService&#125;, which is a more extensive * interface. The &#123;@link ThreadPoolExecutor&#125; class provides an * extensible thread pool implementation. The &#123;@link Executors&#125; class * provides convenient factory methods for these Executors. * * &lt;p&gt;Memory consistency effects: Actions in a thread prior to * submitting a &#123;@code Runnable&#125; object to an &#123;@code Executor&#125; * &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt; * its execution begins, perhaps in another thread. * * @since 1.5 * @author Doug Lea */ public interface Executor &#123; /** * Executes the given command at some time in the future. The command * may execute in a new thread, in a pooled thread, or in the calling * thread, at the discretion of the &#123;@code Executor&#125; implementation. * 任务在哪个线程执行是由 Executor 的实现来决定的。 * * @param command the runnable task * @throws RejectedExecutionException if this task cannot be * accepted for execution * @throws NullPointerException if command is null */ void execute(Runnable command);&#125;","categories":[{"name":"Netty","slug":"Netty","permalink":"https://www.xiaojianblog.top/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://www.xiaojianblog.top/tags/Netty/"}]},{"title":"Netty源码分析(一)NioEventLoopGroup","slug":"Netty源码分析-一-NioEventLoopGroup","date":"2019-07-09T08:36:18.000Z","updated":"2019-08-01T00:53:24.000Z","comments":true,"path":"2019/07/09/Netty源码分析-一-NioEventLoopGroup/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/09/Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80-NioEventLoopGroup/","excerpt":"前言​ Netty内部都是通过线程在处理各种数据，EventLoopGroup就是用来管理调度他们的，注册Channel，管理他们的生命周期 。 ​ NioEventLoopGroup 字面含义就是”非阻塞的事件循环组”，其实就是一个死循环。NioEventLoopGroup 里面有一堆的 NioEventLoop，而 NioEventLoopGroup 的作用就是完成变量的赋值。","text":"前言​ Netty内部都是通过线程在处理各种数据，EventLoopGroup就是用来管理调度他们的，注册Channel，管理他们的生命周期 。 ​ NioEventLoopGroup 字面含义就是”非阻塞的事件循环组”，其实就是一个死循环。NioEventLoopGroup 里面有一堆的 NioEventLoop，而 NioEventLoopGroup 的作用就是完成变量的赋值。 NioEventLoopGroup下面来分析 NioEventLoopGroup 类进行实例化的流程中经历了什么。 NioEventLoopGroup类层次结构类图： 对于NioEventLoopGroup核心的类继承关系就是： NioEventLoopGroup –&gt; MultithreadEventLoopGroup –&gt; MultithreadEventExecutorGroup 下面从这三个类出发分析NioEventLoopGroup实例化过程。 NioEventLoopGroup实例化过程时序图： NioEventLoopGroup构造函数1234567891011121314151617181920/** * 默认是0 * 后面会在MultithreadEventLoopGroup 初始化为 CPU核心数*2 */public NioEventLoopGroup() &#123; this(0);&#125;/** * 这里设置了NioEventLoopGroup线程池中每个线程执行器Executor默认是null * (这里设置为null, 在后面的构造器中会判断，如果为null就实例化一个线程执行器) */public NioEventLoopGroup(int nThreads) &#123; this(nThreads, (Executor) null);&#125;public NioEventLoopGroup(int nThreads, Executor executor) &#123; this(nThreads, executor, SelectorProvider.provider());&#125; 我们这里先停下来分析一下SelectorProvider.provider() 12345678910111213141516171819202122232425262728293031323334353637383940// SelectorProvider provider是一个单例,static类型private static SelectorProvider provider = null;// SelectorProvider.provider的实现，产生了一个WindowsSelectorProviderpublic static SelectorProvider provider() &#123; synchronized (lock) &#123; if (provider != null) return provider; return AccessController.doPrivileged( new PrivilegedAction&lt;SelectorProvider&gt;() &#123; public SelectorProvider run() &#123; if (loadProviderFromProperty()) return provider; if (loadProviderAsService()) return provider; provider = sun.nio.ch.DefaultSelectorProvider.create(); return provider; &#125; &#125;); &#125; &#125;public class DefaultSelectorProvider &#123; private DefaultSelectorProvider() &#123; &#125; public static SelectorProvider create() &#123; return new WindowsSelectorProvider(); &#125;&#125;public class WindowsSelectorProvider extends SelectorProviderImpl &#123; public WindowsSelectorProvider() &#123; &#125; // WindowsSelectorProvider的openSelector会生成一个WindowsSelectorImpl public AbstractSelector openSelector() throws IOException &#123; return new WindowsSelectorImpl(this); &#125;&#125; 这段代码我们也可以看到几点: SelectorProvider provider是一个单例,static类型 SelectorProvider.provider的实现，产生了一个WindowsSelectorProvider WindowsSelectorProvider的openSelector会生成一个WindowsSelectorImpl 这个先记下来，也许后面分析会有用我们接着看NioEventLoopGroup构造函数 123456789101112131415161718/** * 默认的选择策略工厂DefaultSelectStrategyFactory */public NioEventLoopGroup(int nThreads, Executor executor, final SelectorProvider selectorProvider) &#123; this(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);&#125;/** * 调用父类MultithreadEventLoopGroup的构造器 * 添加了线程池对拒绝任务的处理策略 RejectedExecutionHandlers */public NioEventLoopGroup(int nThreads, Executor executor, final SelectorProvider selectorProvider, final SelectStrategyFactory selectStrategyFactory) &#123; super(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());&#125; MultithreadEventLoopGroup构造函数123456789101112131415161718192021/** * 在MultithreadEventLoopGroup的静态代码段 * 将DEFAULT_EVENT_LOOP_THREADS赋值为CPU核心数*2 */static &#123; DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt( &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2)); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;, DEFAULT_EVENT_LOOP_THREADS); &#125;&#125;/** * 构造器被定义成protect，表示只能在NioEventLoopGroup中被调用，一定层度上的保护作用。 * 对线程数进行了判断，当nThreads为0 的时候就设置成 DEFAULT_EVENT_LOOP_THREADS 这个常量。 * 调用的基类MultithreadEventExecutorGroup的构造器 */protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) &#123; super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);&#125; MultithreadEventExecutorGroup构造函数12345678910/** * 构造器里面多传入了一个参数 DefaultEventExecutorChooserFactory.INSTANCE * 通过这个EventLoop选择器工厂可以实例化GenericEventExecutorChooser这个类， * 这个类是EventLoopGroup线程池里面的EventLoop的选择器， * 调用GenericEventExecutorChooser.next() 方法可以从线程池中选择出一个合适的EventLoop线程。 * 然后就是重载调用MultithreadEventExecutorGroup类的构造器 */protected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object... args) &#123; this(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);&#125; MultithreadEventExecutorGroup的核心代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * 最终的创建实例构造器 * * @param nThreads 该实例将使用的线程数 * @param executor 将要使用的executor, 默认为null * @param chooserFactory 将要使用的EventExecutorChooserFactory * @param args arguments which will passed to each &#123;@link #newChild(Executor, * Object...)&#125; call */protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args) &#123; /** 1.初始化线程池 */ // 参数校验nThread合法性， if (nThreads &lt;= 0) &#123; throw new IllegalArgumentException(String.format(&quot;nThreads: %d (expected: &gt; 0)&quot;, nThreads)); &#125; /* * executor校验非空, 如果为空就创建ThreadPerTaskExecutor, 该类实现了 Executor接口 * 这个executor 是用来执行线程池中的所有的线程，也就是所有的NioEventLoop，其实从 * NioEventLoop构造器中也可以知道，NioEventLoop构造器中都传入了executor这个参数。 */ if (executor == null) &#123; executor = new ThreadPerTaskExecutor(newDefaultThreadFactory()); &#125; // 这里的children数组，其实就是线程池的核心实现，线程池中就是通过指定的线程数组来实现线程池； // 数组中每个元素其实就是一个EventLoop，EventLoop是EventExecutor的子接口。 children = new EventExecutor[nThreads]; // for循环实例化children数组，NioEventLoop对象 for (int i = 0; i &lt; nThreads; i ++) &#123; boolean success = false; try &#123; // newChild(executor, args) 函数在NioEventLoopGroup类中实现了, // 实质就是就是存入了一个 NIOEventLoop类实例 children[i] = newChild(executor, args); success = true; &#125; catch (Exception e) &#123; throw new IllegalStateException(&quot;failed to create a child event loop&quot;, e); &#125; finally &#123; // 如果构造失败, 就清理资源 if (!success) &#123; for (int j = 0; j &lt; i; j ++) &#123; children[j].shutdownGracefully(); &#125; for (int j = 0; j &lt; i; j ++) &#123; EventExecutor e = children[j]; try &#123; while (!e.isTerminated()) &#123; e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS); &#125; &#125; catch (InterruptedException interrupted) &#123; Thread.currentThread().interrupt(); break; &#125; &#125; &#125; &#125; &#125;//end foreach /** 2.实例化线程工厂执行器选择器: 根据children获取选择器 * chooserFactory的类型是DefaultEventExecutorChooserFactory * 所以newChooser调用的是DefaultEventExecutorChooserFactory.newChooser方法 */ chooser = chooserFactory.newChooser(children); /** 3.为每个EventLoop线程添加 线程终止监听器*/ final FutureListener&lt;Object&gt; terminationListener = new FutureListener&lt;Object&gt;() &#123; @Override public void operationComplete(Future&lt;Object&gt; future) throws Exception &#123; if (terminatedChildren.incrementAndGet() == children.length) &#123; terminationFuture.setSuccess(null); &#125; &#125; &#125;; for (EventExecutor e: children) &#123; e.terminationFuture().addListener(terminationListener); &#125; /** 4.将children 添加到对应的set集合中去重，表示只可读。*/ Set&lt;EventExecutor&gt; childrenSet = new LinkedHashSet&lt;EventExecutor&gt;(children.length); Collections.addAll(childrenSet, children); readonlyChildren = Collections.unmodifiableSet(childrenSet);&#125; ​ newChild初始化 实例类是NioEventLoopGroup.java，返回NioEventLoop对象 12345protected EventLoop newChild(Executor executor, Object... args) throws Exception &#123; return new NioEventLoop(this, executor, (SelectorProvider) args[0], ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);&#125; ​ NIOEventLoopGroup的线程池实现其实就是一个NIOEventLoop数组，一个NIOEventLoop可以理解成就是一个线程。 NioEventLoop​ NioEventLoop 继承于 SingleThreadEventLoop；SingleThreadEventLoop 又继承于 SingleThreadEventExecutor； ​ SingleThreadEventExecutor 是 netty 中对本地线程的抽象, 它内部有一个 Thread thread 属性, 存储了一个本地 Java 线程. 因此我们可以认为, 一个 NioEventLoop 其实和一个特定的线程绑定, 并且在其生命周期内, 绑定的线程都不会再改变。 NioEventLoop 类层次结构类图： 对于NioEventLoop 核心的类继承关系就是： ​ NioEventLoop -&gt; SingleThreadEventLoop -&gt; SingleThreadEventExecutor -&gt; AbstractScheduledEventExecutor ​ 在 AbstractScheduledEventExecutor 中, Netty 实现了 NioEventLoop 的 schedule 功能, 即我们可以通过调用一个 NioEventLoop 实例的 schedule()方法来运行一些定时任务. 而在 SingleThreadEventLoop 中, 又实现了任务队列的功能, 通过它, 我们可以调用一个 NioEventLoop 实例的 execute() 方法来向任务队列中添加一个 task, 并由 NioEventLoop 进行调度执行. ​ 通常来说, NioEventLoop 肩负着两种任务,: （1）作为 IO 线程, 执行与 Channel 相关的 IO 操作, 包括调用 select 等待就绪的 IO 事件、读写数据与数据的处理等; ​ （2）作为任务队列, 执行 taskQueue 中的任务, 例如用户调用 eventLoop.schedule 提交的定时任务也是这个线程执行的. NioEventLoop 的实例化过程时序图： NioEventLoop 的构造函数1234567891011121314151617NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123; //调用父类构造器 super(parent, executor, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler); if (selectorProvider == null) &#123; throw new NullPointerException(&quot;selectorProvider&quot;); &#125; if (strategy == null) &#123; throw new NullPointerException(&quot;selectStrategy&quot;); &#125; provider = selectorProvider; final SelectorTuple selectorTuple = openSelector(); //new 一个selector实例，具体的类与平台和底层有关 selector = selectorTuple.selector; unwrappedSelector = selectorTuple.unwrappedSelector; selectStrategy = strategy;&#125; ​ 需要注意的是：构造器里面传入了 NioEventLoopGroup、Executor、SelectorProvider、SelectStrategyFactory、RejectedExecutionHandler。从这里可以看出，一个NioEventLoop属于某一个NioEventLoopGroup， 且处于同一个NioEventLoopGroup下的所有NioEventLoop 公用Executor、SelectorProvider、SelectStrategyFactory和RejectedExecutionHandler。 ​ 还有一点需要注意的是，这里的 SelectorProvider 构造参数传入的是通过在NioEventLoopGroup里面的构造器里面的 SelectorProvider.provider(); 方式获取的， 而这个方法返回的是一个单例的SelectorProvider， 所以所有的NioEventLoop公用同一个单例SelectorProvider。 SingleThreadEventLoop 的构造函数123456protected SingleThreadEventLoop(EventLoopGroup parent, Executor executor, boolean addTaskWakesUp, int maxPendingTasks, RejectedExecutionHandler rejectedExecutionHandler) &#123; super(parent, executor, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler); tailTasks = newTaskQueue(maxPendingTasks);&#125; ​ 这里除了调用父类SingleThreadEventExecutor的构造器以外， 就是实例化了 tailTasks 这个变量； 对于tailTasks在SingleThreadEventLoop属性的定义如下： private final Queue tailTasks;// 尾部任务队列 ​ 队列的数量maxPendingTasks参数默认是SingleThreadEventLoop.DEFAULT_MAX_PENDING_TASK，其实就是Integer.MAX_VALUE; 对于new的这个队列，其实就是一个LinkedBlockingQueue 无界队列。 SingleThreadEventExecutor 的构造函数12345678910111213protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor, boolean addTaskWakesUp, int maxPendingTasks, RejectedExecutionHandler rejectedHandler) &#123; // 设置EventLoop所属于的EventLoopGroup super(parent); this.addTaskWakesUp = addTaskWakesUp; //默认是Integer.MAX_VALUE this.maxPendingTasks = Math.max(16, maxPendingTasks); this.executor = ObjectUtil.checkNotNull(executor, &quot;executor&quot;); //创建EventLoop的任务队列, 默认是 LinkedBlockingQueue taskQueue = newTaskQueue(this.maxPendingTasks); rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, &quot;rejectedHandler&quot;);&#125; 在这个类中才真正的实现了线程的构造。里面就做了两件事 ： new 了一个新的线程，新的线程还分配了一个任务，任务的内容就是调用本类中的一个 run 方法，在NioEventLoop中实现。 设置任务队列为LinkedBlockQueue ​ Thread 的初始化在doStartThread这个方法中，而这个方法被startThread方法调用，而startThread 这个方法被execute方法调用，也就是提交任务的入口，这个方法是Executor接口的唯一方法。也就是说，所有我们通过EventLoop的execute方法提交的任务都将被这个Thread线程来执行。 ​ 我们还知道一个事实，EventLoop是一个循环执行来消耗Channel事件的类，那么它必然会有一个类似循环的方法来作为任务，来提交给这个Thread来执行，而这可以在doStartThread方法中被发现，因为这个方法非常重要，所以下面展示了它的实现细节 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private void doStartThread() &#123; assert thread == null; executor.execute(new Runnable() &#123; @Override public void run() &#123; thread = Thread.currentThread(); if (interrupted) &#123; thread.interrupt(); &#125; boolean success = false; updateLastExecutionTime(); try &#123; // 这个run方法的具体实现在NioEventLoop中 SingleThreadEventExecutor.this.run(); success = true; &#125; catch (Throwable t) &#123; logger.warn(&quot;Unexpected exception from an event executor: &quot;, t); &#125; finally &#123; for (;;) &#123; int oldState = state; if (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet( SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) &#123; break; &#125; &#125; // Check if confirmShutdown() was called at the end of the loop. if (success &amp;&amp; gracefulShutdownStartTime == 0) &#123; logger.error(&quot;Buggy &quot; + EventExecutor.class.getSimpleName() + &quot; implementation; &quot; + SingleThreadEventExecutor.class.getSimpleName() + &quot;.confirmShutdown() must be called &quot; + &quot;before run() implementation terminates.&quot;); &#125; try &#123; // Run all remaining tasks and shutdown hooks. for (;;) &#123; if (confirmShutdown()) &#123; break; &#125; &#125; &#125; finally &#123; try &#123; cleanup(); &#125; finally &#123; STATE_UPDATER.set(SingleThreadEventExecutor.this, ST_TERMINATED); threadLock.release(); if (!taskQueue.isEmpty()) &#123; logger.warn( &quot;An event executor terminated with &quot; + &quot;non-empty task queue (&quot; + taskQueue.size() + &#x27;)&#x27;); &#125; terminationFuture.setSuccess(null); &#125; &#125; &#125; &#125; &#125;); &#125; ​ 上面所提到的事件循环就是通过 SingleThreadEventExecutor.this.run() 这句话来触发的。这个run方法的具体实现在NioEventLoop中。 NioEventLoop其成员变量如下所示，主要是多路复用器 Selector 12345678// 经过优化的 selectorprivate Selector selector;// 未经优化的原生 selectorprivate Selector unwrappedSelector;// 经过优化的 SelectionKeySetprivate SelectedSelectionKeySet selectedKeys;// 用来创建 Selector、Channelprivate final SelectorProvider provider; Selector 的创建是在 openSelector 方法中，根据 DISABLE_KEYSET_OPTIMIZATION 来判断是否对 SelectionKey 进行优化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586private SelectorTuple openSelector() &#123; final Selector unwrappedSelector; try &#123; // 创建 Selector unwrappedSelector = provider.openSelector(); &#125; catch (IOException e) &#123; throw new ChannelException(&quot;failed to open a new selector&quot;, e); &#125; // 如果不需要优化 SelectorKey，则立即返回，默认就是不需要优化。 if (DISABLE_KEYSET_OPTIMIZATION) &#123; return new SelectorTuple(unwrappedSelector); &#125; // 否则，进行优化 final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet(); Object maybeSelectorImplClass = AccessController.doPrivileged( new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; try &#123; return Class.forName( &quot;sun.nio.ch.SelectorImpl&quot;, false, PlatformDependent.getSystemClassLoader()); &#125; catch (Throwable cause) &#123; return cause; &#125; &#125; &#125;); if (!(maybeSelectorImplClass instanceof Class) || !((Class&lt;?&gt;) maybeSelectorImplClass).isAssignableFrom( unwrappedSelector.getClass())) &#123; if (maybeSelectorImplClass instanceof Throwable) &#123; Throwable t = (Throwable) maybeSelectorImplClass; logger.trace(&quot;failed to instrument a special java.util.Set into: &#123;&#125;&quot;, unwrappedSelector, t); &#125; return new SelectorTuple(unwrappedSelector); &#125; final Class&lt;?&gt; selectorImplClass = (Class&lt;?&gt;) maybeSelectorImplClass; Object maybeException = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; try &#123; Field selectedKeysField = selectorImplClass.getDeclaredField(&quot;selectedKeys&quot;); Field publicSelectedKeysField = selectorImplClass.getDeclaredField(&quot;publicSelectedKeys&quot;); Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField); if (cause != null) &#123; return cause; &#125; cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField); if (cause != null) &#123; return cause; &#125; // 优化，用 Netty 实现的 SelectedSelectionKeySet 替换 NIO 原生的 selectedKeysField.set(unwrappedSelector, selectedKeySet); publicSelectedKeysField.set(unwrappedSelector, selectedKeySet); return null; &#125; catch (NoSuchFieldException e) &#123; return e; &#125; catch (IllegalAccessException e) &#123; return e; &#125; &#125; &#125;); if (maybeException instanceof Exception) &#123; selectedKeys = null; Exception e = (Exception) maybeException; logger.trace(&quot;failed to instrument a special java.util.Set into: &#123;&#125;&quot;, unwrappedSelector, e); return new SelectorTuple(unwrappedSelector); &#125; selectedKeys = selectedKeySet; logger.trace(&quot;instrumented a special java.util.Set into: &#123;&#125;&quot;, unwrappedSelector); return new SelectorTuple(unwrappedSelector, new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));&#125; 从上面这段代码我们可以看出这几点 NioEventLoop里面保存了SelectorProvider selectorProvider, Selector selector, unwrappedSelector(类型是WindowsSelectorImpl) selector, unwrappedSelector是通过provider.openSelector()打开的.根据之前的介绍，provider之前介绍的类型是WindowsSelectorProvider，然后它的openSelector会生成一个WindowsSelectorImpl，所以provider.openSelector()得到是WindowsSelectorImpl，WindowsSelectorImpl的继承关系如下： NioEventLoop 的核心 run 方法 ：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Override protected void run() &#123; /** 死循环：NioEventLoop 事件循环的核心就是这里! */ for (;;) &#123; try &#123; /** * 1.通过 select/selectNow 调用查询当前是否有就绪的 IO 事件, * 当 selectStrategy.calculateStrategy() 返回的是 CONTINUE, * 就结束此轮循环,进入下一轮循环; * 当返回的是 SELECT, 就表示任务队列为空,就调用select(Boolean); */ switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123; case SelectStrategy.CONTINUE: continue; case SelectStrategy.SELECT: select(wakenUp.getAndSet(false)); if (wakenUp.get()) &#123; selector.wakeup(); &#125; // fall through default: &#125; //2. 当有IO事件就绪时, 就会处理这些IO事件 cancelledKeys = 0; needsToSelectAgain = false; //ioRatio表示:此线程分配给IO操作所占的时间比 //(即运行processSelectedKeys耗时在整个循环中所占用的时间). final int ioRatio = this.ioRatio; if (ioRatio == 100) &#123; try &#123; //查询就绪的 IO 事件, 然后处理它; processSelectedKeys(); &#125; finally &#123; //运行 taskQueue 中的任务. runAllTasks(); &#125; &#125; else &#123; final long ioStartTime = System.nanoTime(); try &#123; //查询就绪的 IO 事件, 然后处理它; processSelectedKeys(); &#125; finally &#123; // Ensure we always run tasks. final long ioTime = System.nanoTime() - ioStartTime; runAllTasks(ioTime * (100 - ioRatio) / ioRatio); &#125; &#125; &#125; catch (Throwable t) &#123; handleLoopException(t); &#125; // Always handle shutdown even if the loop processing threw an exception. try &#123; if (isShuttingDown()) &#123; closeAll(); if (confirmShutdown()) &#123; return; &#125; &#125; &#125; catch (Throwable t) &#123; handleLoopException(t); &#125; &#125; &#125; 上面函数中的一个死循环 for(;;) 就是NioEventLoop事件循环执行机制。死循环中的业务简单点就是： （1）通过调用 select/selectNow 函数，等待 IO 事件； （2）当有IO事件就绪时, 获取事件类型，分别处理这些IO事件，处理IO事件函数调用就是 processSelectedKeys(); 总结我们来总结下NioEventLoopGroup的实例化过程，可以得到以下几点： 1. NioEventLoopGroup的父类MultithreadEventExecutorGroup包含一个NioEventLoop数组children，数组的大小等于nThreads线程数目。如果没有指定，默认一般是cpu核心数 x 2 2. NioEventLoopGroup和NioEventLoop一样都是继承自Executor，但是NioEventLoopGroup又包含多个NioEventLoop(children数组) 3. NioEventLoopGroup继承自MultithreadEventLoopGroup，而NioEventLoop继承自SingleThreadEventLoop 4. MultithreadEventLoopGroup有个chooser，执行next方法的时候，会选择下一个NioEventLoop对象，虽然并不知道两个chooser算法有何区别。 5. NioEventLoopGroup里面重写了newChild方法，里面实例化NioEventLoop。 6. NioEventLoop里面包含了Selector，类型是WindowsSelectorImpl","categories":[{"name":"Netty","slug":"Netty","permalink":"https://www.xiaojianblog.top/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://www.xiaojianblog.top/tags/Netty/"},{"name":"Nio","slug":"Nio","permalink":"https://www.xiaojianblog.top/tags/Nio/"}]},{"title":"Reactor线程模型","slug":"Reactor线程模型","date":"2019-07-08T11:56:37.000Z","updated":"2019-07-15T13:43:31.000Z","comments":true,"path":"2019/07/08/Reactor线程模型/","link":"","permalink":"https://www.xiaojianblog.top/2019/07/08/Reactor%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/","excerpt":"概述​ 一般情况下，I/O 复用机制需要事件分发器（event dispatcher）。 事件分发器的作用，即将那些读写事件源分发给各读写事件的处理者，就像送快递的在楼下喊: 谁谁谁的快递到了， 快来拿吧！开发人员在开始的时候需要在分发器那里注册感兴趣的事件，并提供相应的处理者（event handler)，或者是回调函数；事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调函数。 ​ 涉及到事件分发器的两种模式称为：Reactor和Proactor。Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的。而Netty 框架遵循的是 Reactor 线程模型。","text":"概述​ 一般情况下，I/O 复用机制需要事件分发器（event dispatcher）。 事件分发器的作用，即将那些读写事件源分发给各读写事件的处理者，就像送快递的在楼下喊: 谁谁谁的快递到了， 快来拿吧！开发人员在开始的时候需要在分发器那里注册感兴趣的事件，并提供相应的处理者（event handler)，或者是回调函数；事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调函数。 ​ 涉及到事件分发器的两种模式称为：Reactor和Proactor。Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的。而Netty 框架遵循的是 Reactor 线程模型。 Reactor单线程模型这个线程模型指的是所有的nio操作都是在一个线程中去完成的。nio线程的职责如下： 作为NIO服务端，接收客户端的TCP连接； 作为NIO客户端，向服务端发起TCP连接； 读取通信对端的请求或是应答消息； 向通信对端发送消息或者应答消息。 ​ 由于Reactor模式是异步非阻塞I/O，所有的I/O操作都不会导致阻塞。理论上一个线程可以独立处理所有的I/O相关的操作。例如，通过 Acceptor 接收客户端的连接，当链路建立完成后通过 Dispatcher 将对应的 ByteBuffer 派发到指定的 handler 上，进行消息解码。用户线程消息编码后通过 NIO线程将消息发送给客户端。在一些小容量的应用场景下，可以使用单线程模型，但对于高负载，大并发的应用场景确不合适，主要原因如下： 一个 NIO线程同时处理成百上千的链路，性能无法满足，即便 NIO线程的cpu达到100%,也无法满足海量的消息编码、解码、读取和发送。 NIO线程负载过重，处理速度变慢，这会导致大量的客户端的连接超时，超时之后往往会进行重发，这更加加重了NIO线程的负载，最终导致大量消息积压和处理超时，成为性能瓶颈。 ​ 可靠性问题：一旦 NIO线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。 Reactor多线程模型Rector多线程模型与单线程模型最大的区别就是有一组NIO线程处理IO操作，它的原理图如下： Reactor多线程模型的特点： 有专门一个NIO线程-Acceptor线程用于监听服务端，接收客户端的TCP连接请求； 网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送； 1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题。 ​ 在绝大多数场景下，Reactor多线程模型都可以满足性能需求；但是，在极个别特殊场景中，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题，为了解决性能问题，产生了第三种Reactor线程模型-主从Reactor多线程模型。 Reactor主从多线程模型​ 主从Reactor线程模型的特点是：服务端用于接收客户端连接的不再是个1个单独的NIO线程，而是一个独立的NIO线程池。Acceptor接收到客户端TCP连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel注册到IO线程池（sub reactor线程池）的某个IO线程上，由它负责SocketChannel的读写和编解码工作。Acceptor线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端subReactor线程池的IO线程上，由IO线程负责后续的IO操作。 ​ 它的线程模型如下图所示： ​ 利用主从NIO线程模型，可以解决1个服务端监听线程无法有效处理所有客户端连接的性能不足问题。它的工作流程总结如下： 从主线程池中随机选择一个 Reactor线程作为 Acceptor线程，用于绑定监听端口，接收客户端连接； Acceptor线程接收客户端连接请求之后创建新的 SocketChannel，将其注册到主线程池的其它 Reactor线程上，由其负责接入认证、IP黑白名单过滤、握手等操作； 步骤2完成之后，业务层的链路正式建立，将 SocketChannel从主线程池的 Reactor线程的多路复用器上摘除，重新注册到 Sub Reactor线程池的线程上，用于处理I/O的读写操作。 Netty线程模型​ 服务端用于接收客户端连接的不再是个1个单独的NIO线程，而是一个独立的NIO线程池。Acceptor接收到客户端TCP连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel注册到 I/O 线程池（sub reactor线程池）的某个IO线程上，由它负责SocketChannel的读写和编解码工作。Acceptor线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端subReactor线程池的IO线程上，由IO线程负责后续的IO操作。 ​ 它的线程模型如下图所示： ​ 服务端启动时创建了两个NioEventLoopGroup，一个是boss，一个是worker。实际上他们是两个独立的Reactor线程池，一个用于接收客户端的TCP连接，另一个用于处理I/O相关的读写操作，或则执行系统的Task，定时Task。 ​ Boss线程池职责如下： （1）接收客户端的连接，初始化Channel参数 （2） 将链路状态变更时间通知给ChannelPipeline ​ worker线程池作用是： （1）异步读取通信对端的数据报，发送读事件到ChannelPipeline （2）异步发送消息到通信对端，调用ChannelPipeline的消息发送接口 （3）执行系统调用Task; （4）执行定时任务Task； ​ 通过配置boss和worker线程池的线程个数以及是否共享线程池等方式，netty的线程模型可以在单线程、多线程、主从线程之间切换。 ​ 为了提升性能，netty在很多地方都进行了无锁设计。比如在I/O线程内部进行串行操作，避免多线程竞争造成的性能问题。表面上似乎串行化设计似乎CPU利用率不高，但是通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁串行线程设计性能更优。 ​ netty的NioEventLoop读取到消息之后，直接调用ChannelPipeline的fireChannelRead(Object msg)，只要用户不主动切换线程，一直都是由NioEventLoop调用用户的Handler，期间不进行线程切换，这种串行化设计避免了多线程操作导致的锁竞争，性能角度看是最优的。","categories":[{"name":"Netty","slug":"Netty","permalink":"https://www.xiaojianblog.top/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://www.xiaojianblog.top/tags/Netty/"}]}],"categories":[{"name":"java高级","slug":"java高级","permalink":"https://www.xiaojianblog.top/categories/java%E9%AB%98%E7%BA%A7/"},{"name":"java基础","slug":"java基础","permalink":"https://www.xiaojianblog.top/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"AQS","slug":"AQS","permalink":"https://www.xiaojianblog.top/categories/AQS/"},{"name":"Netty","slug":"Netty","permalink":"https://www.xiaojianblog.top/categories/Netty/"},{"name":"项目","slug":"项目","permalink":"https://www.xiaojianblog.top/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.xiaojianblog.top/tags/java/"},{"name":"JVM","slug":"JVM","permalink":"https://www.xiaojianblog.top/tags/JVM/"},{"name":"AQS源码","slug":"AQS源码","permalink":"https://www.xiaojianblog.top/tags/AQS%E6%BA%90%E7%A0%81/"},{"name":"Netty","slug":"Netty","permalink":"https://www.xiaojianblog.top/tags/Netty/"},{"name":"项目","slug":"项目","permalink":"https://www.xiaojianblog.top/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"kisso","slug":"kisso","permalink":"https://www.xiaojianblog.top/tags/kisso/"},{"name":"单点登录","slug":"单点登录","permalink":"https://www.xiaojianblog.top/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"},{"name":"秒杀","slug":"秒杀","permalink":"https://www.xiaojianblog.top/tags/%E7%A7%92%E6%9D%80/"},{"name":"Nio","slug":"Nio","permalink":"https://www.xiaojianblog.top/tags/Nio/"}]}